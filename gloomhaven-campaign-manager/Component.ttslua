local EventManager = require("ge_tts.EventManager")
local Logger = require("sebaestschjin-tts.Logger")
local Object = require("sebaestschjin-tts.Object")
local ObjectState = require("sebaestschjin-tts.ObjectState")
local Search = require("sebaestschjin-tts.Search")
local StringUtil = require("sebaestschjin-tts.StringUtil")
local TableUtil = require("sebaestschjin-tts.TableUtil")
local Utils = require("sebaestschjin-tts.Utils")
local WrappedDeck = require("sebaestschjin-tts.WrappedDeck")

local EventType = require("gloomhaven-campaign-manager.EventType")
local Game = require("gloomhaven-campaign-manager.Game")

---
--- Handles everything about the different game components required to load and save a Gloomhaven-Campaign. Has methods
--- to locate and place those components.
---
local Component = {}

---@type table<string, string>
Component.Tag = {
    CampaignManager = "Gloomhaven - Campaign Manager",
    InactiveCharacter = "Gloomhaven - Inactive Character",
}

--- A list of GUIDs of relevant components.
local Guid = {
    Gamebox = "346ed5",
    ForgottenCirclesBox = "5e28e8",
    LockedClasses = "1e6549",
    ScenarioBook = "f3404a",
    RuleBook = "c9d3f5",
    OpeningConditions = "30ae8e",
    RetirementSheet = "a30c94",
    TownRecords = "a6c771",
    TreasureDeck = "284016",
    PartySheet = "6d3de2",
    LastBox = "fdef02", -- tinkerer
    BeforeLastBox = "ec1d2a", -- cragheart
    Map = "9cc037",
    AchievementBag = "3ea749", -- Bag containing the Achievement board
    SanctuarySticker = "800847",
    DeckMat = "a75fcd",
    CityEventsDeckInitial = "759349",
    CityEventsDeck = "f13efd",
    RoadEventsDeckInitial = "83de73",
    RoadEventsDeck = "f08b69",
    CityMat = "f3ffb7",
    EventsMat = "b53fb2",
    OldEventsMat = "41393b",
    FantasySetupScripts = "75ab50",
    HpTrackerBag = "6c775e",
    XpTrackerBag = "0625c4",
}

--- A list of components with multiple GUIDs (e.g. where newer versions have different GUIDs) or where multiple objects exist.
local Guids = {
    Zones = --[[---@type GUID[] ]] { "49a4e0", "dac936", "62cd94", "963318" },
    AddPlayers = --[[---@type GUID[] ]] { "3f0cda", "4d61da", "f98ff8", "d0f661" },
    AchievementBoard = --[[---@type GUID[] ]] { "43d5b8", "546b57" },
    ModifierDecks = --[[---@type GUID[] ]] { "bb85b9", "d23231", "74238d", "20d00f" }
}

--- A list of CustomDeck-IDs to identify cards. May have multiple entries if newer version have other IDs.
---@type table<string, number[]>
local DeckIds = {
    Quests = { 1753, 1997 },
    RandomScenarios = { 1930 },
}

--- A list of names to identify components by.
local Names = {
    CharacterMat = "Character Mat",
    AbilityDeck = "Advanced Abilities",
    StartingAbilityDeck = "Starting Abilities",
    AttackModifierDeck = "Attack Modifiers",
    AchievementBoard = "Achievements",
    InactiveCharacter = "Repacked",
    PlayerMat = "Player Mat",
    CharacterSheet = "Character Sheet",
    AttachModifierCard = "Attack Modifier",
    Summons = "Summons",
    Trackers = "Trackers",
}

local TableHigh = 0.65

--- A list of positions where components should be placed.
local Positions = {
    -- relative to player zone
    QuestCard = --[[---@type tts__NumVectorShape]] { 1, 2, -19 },
    ItemUnequipped = --[[---@type tts__NumVectorShape]] { -7, 2, -7 },
    Hand = --[[---@type tts__NumVectorShape]] { 0, 3, 5 },
    SecondHand = --[[---@type tts__NumVectorShape]] { 0, 3, -2 },
    AbilityDeck = --[[---@type tts__NumVectorShape]] { -3.2, 2, -15.17 },
    AttackModifierDiscard = --[[---@type tts__NumVectorShape]] { -4.69, 2, 26.5 },
    CharacterSheet = --[[---@type tts__NumVectorShape]] { 6.31, 0, -17 },
    Figurine = --[[---@type tts__NumVectorShape]]  { 0, 0, 23.23 },
    AttackModifierDeck = --[[---@type tts__NumVectorShape]] { -7, 0, -14.27 },
    CharacterBox = --[[---@type tts__NumVectorShape]] { 0.62, 0, -15.77 },
    PlayerMat = { 0, -1, 17.23 },
    -- absolute
    AchievementBoard = --[[---@type tts__NumVectorShape]] { 87.26, 2, 26.12 },
    OpeningConditions = --[[---@type tts__NumVectorShape]] { 65.19, 1.70, -29.55 },
    RetirementSheet = --[[---@type tts__NumVectorShape]] { 77.88, 1.70, -33.34 },
    ScenarioBook = --[[---@type tts__NumVectorShape]] { 63.88, 2, 37.89 },
    RuleBook = --[[---@type tts__NumVectorShape]] { -64.31, 2, -41.68 },
    TownRecords = --[[---@type tts__NumVectorShape]] { 73.94, 2, 34.10 },
    TreasureDeck = --[[---@type tts__NumVectorShape]] { -75, 2, -5.3 },
    ScenarioDiscard = --[[---@type tts__NumVectorShape]] { 56.0, 2, -1.52 },
    CompletedQuests = --[[---@type tts__NumVectorShape]] { 56.0, 2, -12.5 },
    LootedTreasures = --[[---@type tts__NumVectorShape]]{ -68, 2, 17 },
    InactiveCharacter = --[[---@type tts__NumVectorShape]] { -66.29, 1.6, -23.91 },
}

local Scales = {
    InactiveCharacterZone = { 8.14, 10, 8.63 },
    CharacterBox = { 0.48, 0.48, 0.48 },
}

--- A list of snap points on the player mat, e.g. for item slots.
---@type table<gh_Save_Character_Item_Position, number>
local PlayerMatItemPositions = {
    Head = 15,
    Armor = 16,
    HandLeft = 17,
    HandRight = 18,
    Boots = 19,
    Bag1 = 12,
    Bag2 = 13,
    Bag3 = 14,
    Bag4 = 22,
    Bag5 = 23,
    Bag6 = 24,
    Bag7 = 25,
    Active1 = 6,
    Active2 = 7,
    Active3 = 8,
    Active4 = 9,
}

--- A list of snap points on the deck mat containing different decks.
---@type table<string, number>
local DeckMatSnapPoints = {
    MinusOneDeck = 3,
    RoadEventsInitial = 4,
    RoadEvents = 5,
    CityEventsInitial = 6,
    CityEvents = 7,
    RandomScenarios = 8,
    Quests = 11,
    BattleGoals = 12,
}

--- A list of snap points on the city deck mat containing different decks.
local CityMatSnapPoints = {
    Shop = 1,
    RewardItems = 13,
}

--- Player color associated with each player
---@type tts__PlayerColor[]
Component.PlayerColors = { "Red", "White", "Blue", "Green", }

--- Information about an event deck.
---@shape gh_EventDeckInfo
---@field initialDeckAt number
---@field deckAt number
---@field atEventMat number
---@field name string
---@field oldMat nil | GUID

---@type table<string, gh_EventDeckInfo>
Component.EventDecks = {
    ["city"] = {
        name = "City Events",
        initialDeckAt = DeckMatSnapPoints.CityEventsInitial,
        deckAt = DeckMatSnapPoints.CityEvents,
        atEventMat = 2,
    },
    ["road"] = {
        name = "Road Events",
        initialDeckAt = DeckMatSnapPoints.RoadEventsInitial,
        deckAt = DeckMatSnapPoints.RoadEvents,
        atEventMat = 1,
        oldMat = Guid.OldEventsMat,
    },
}

---@shape gh_PlayerComponent
---@field name nil | string
---@field class nil | boolean
---@field snapPoint nil | number
---@field position nil | tts__VectorShape
---@field rotation nil | tts__VectorShape
---@field locked nil | boolean
---@field playerBag nil | GUID[]
---@field bag nil | GUID
---@field event nil | string

---@type table<string, gh_PlayerComponent>
Component.PlayerComponent = {
    CharacterMat = {
        name = Names.CharacterMat,
        snapPoint = 3,
        locked = true,
    },
    Figurine = {
        class = true,
        position = Positions.Figurine,
        rotation = { 0, 0, 0 },
        event = EventType.Character.Figurine,
    },
    Summons = {
        name = Names.Summons,
        snapPoint = 2,
    },
    Trackers = {
        name = Names.Trackers,
        snapPoint = 1,
    },
    AttackModifierDeck = {
        name = Names.AttackModifierDeck,
        position = Positions.AttackModifierDeck,
        rotation = { 0, 180, 0 },
    },
    CharacterSheet = {
        name = Names.CharacterSheet,
        position = Positions.CharacterSheet,
        rotation = { 0, 180, 0 },
        event = EventType.Character.Sheet,
    },
}

---@type table<string, gh_PlayerComponent>
Component.ExtraPlayerComponent = {
    Hp = {
        snapPoint = 10,
        rotation = { 0, 180, 0 },
        bag = Guid.HpTrackerBag,
        event = EventType.Character.HpTrack,
    },
    Xp = {
        snapPoint = 11,
        rotation = { 0, 180, 0 },
        bag = Guid.XpTrackerBag,
    },
    AttackModifierPlayerDeck = {
        snapPoint = 4,
        rotation = { 0, 180, 180 },
        playerBag = Guids.ModifierDecks,
    },
}

Component.ObjectColor = {
    Red = --[[---@type tts__ColorShape]] { 0.82, 0.25, 0.18, 1 },
    Yellow = --[[---@type tts__ColorShape]] { 0.75, 0.67, 0.56, 1 },
    Black = --[[---@type tts__ColorShape]] { 0.18, 0.047, 0.047, 1 },
    White = --[[---@type tts__ColorShape]] { 0.812, 0.70, 0.60, 1 },
    Invisible = --[[---@type tts__ColorShape]] { 0, 0, 0, 0 },
}

---@param guidName string
---@param search seb_Search_Full
---@return tts__Object
local function findComponent(guidName, search)
    local guid = Guid[guidName]

    local byId = getObjectFromGUID(guid)
    if byId ~= nil then
        return --[[---@not nil]] byId
    end

    local bySearch = Search.inAllObjects(search)
    if bySearch ~= nil then
        Guid[guidName] = (--[[---@not nil]] bySearch).getGUID()
        return --[[---@not nil]] bySearch
    else
        Logger.error("Fatal error! Can not find component %s", guidName)
    end
end

--------------------------------------------------------------------------------
--- Positioning ----------------------------------------------------------------
--------------------------------------------------------------------------------

---@param player number
---@param position tts__VectorShape
---@return tts__Vector
local function relativeToZone(player, position)
    return Component.playerZone(player).getPosition() + Vector(position)
end

local MaxColumn = 40
local positionCounter = 0

---@overload fun(): tts__VectorShape
---@param elevation nil | number
---@return tts__Vector
function Component.safePosition(elevation)
    positionCounter = positionCounter + 1
    local offsetZ = math.floor(positionCounter / MaxColumn)
    return Vector(-23 + (positionCounter * 3), TableHigh + (elevation or 0), -85 - offsetZ)
end

---@param player number
---@param target number
---@return tts__Vector
function Component.handPosition(player, target)
    if target == 1 then
        return relativeToZone(player, Positions.Hand)
    end
    if target == 2 then
        return relativeToZone(player, Positions.SecondHand)
    end
end

---@param player number
---@return tts__Vector
function Component.questPosition(player)
    return relativeToZone(player, Positions.QuestCard)
end

--------------------------------------------------------------------------------
--- Gamebox-Content ------------------------------------------------------------
--------------------------------------------------------------------------------

---@overload fun(guid: GUID, position: tts__VectorShape)
---@param guid GUID
---@param position tts__VectorShape
---@param event nil | string
local function takeFromGamebox(guid, position, event)
    local object = getObjectFromGUID(guid)
    if object == nil then
        Component.gamebox().takeObject({
            guid = guid,
            smooth = false,
            position = position,
            rotation = { 0, 180, 0 },
            callback_function = function()
                if event then
                    Wait.frames(function() EventManager.triggerEvent(--[[---@not nil]] event) end, 1)
                end
            end,
        })
    elseif event then
        EventManager.triggerEvent(--[[---@not nil]] event)
    end
end

---@return tts__Bag
function Component.gamebox()
    return --[[---@type tts__Bag]] findComponent("Gamebox",
            { type = Object.Type.Bag, name = "Unlockable Content" })
end

---@return tts__Bag
function Component.forgottenCirclesBox()
    return --[[---@type tts__Bag]] findComponent("ForgottenCirclesBox",
            { type = Object.Type.Bag, name = "Gloomhaven: Forgotten Circles" })
end

---@return tts__Bag
function Component.lockedClasses()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.LockedClasses)
end

---@return nil | tts__Deck
function Component.treasureDeck()
    return --[[---@type nil | tts__Deck]] getObjectFromGUID(Guid.TreasureDeck)
end

---@return nil | (tts__ObjectState, number)
function Component.treasureDeckData()
    return Search.inContainedObjects(Component.gamebox(), { guid = Guid.TreasureDeck })
end

---@return nil | tts__Object
function Component.retirementSheet()
    return getObjectFromGUID(Guid.RetirementSheet)
end

---@return nil | tts__Object
function Component.openingConditions()
    return findComponent("OpeningConditions", { name = "Opening Conditions" })
end

function Component.placeScenarioBook()
    takeFromGamebox(Guid.ScenarioBook, Positions.ScenarioBook)
end

function Component.placeRuleBook()
    takeFromGamebox(Guid.RuleBook, Positions.RuleBook)
end

function Component.placeTreasureDeck()
    takeFromGamebox(Guid.TreasureDeck, Positions.TreasureDeck, EventType.Placed.Treasure)
end

function Component.placeLockedCharacter()
    takeFromGamebox(Guid.LockedClasses, Component.safePosition(), EventType.Placed.LockedCharacters)
end

function Component.placeOpeningConditions()
    takeFromGamebox(Guid.OpeningConditions, Positions.OpeningConditions, EventType.Placed.OpeningConditions)
end

function Component.placeRetirementSheet()
    takeFromGamebox(Guid.RetirementSheet, Positions.RetirementSheet, EventType.Placed.RetirementSheet)
end

function Component.placeTownRecords()
    Component.gamebox().takeObject({
        guid = Guid.TownRecords,
        position = Positions.TownRecords,
        rotation = { 0, 180, 0 },
        smooth = false
    })
end

function Component.placeSanctuarySticker()
    Component.map().call('unseal')
    Utils.waitForObject(Guid.SanctuarySticker, function()
        EventManager.triggerEvent(EventType.Placed.SanctuarySticker)
    end)
end

function Component.replacePlayerAddButtons()
    for player, add in ipairs(Guids.AddPlayers) do
        local obj = --[[---@not nil]] getObjectFromGUID(add)
        local data = obj.getData()

        local script = Component.scriptOnManager() ..
                Component.scriptButton({
                    tooltip = "Right click to Remove Player!",
                    click_function = "packBox",
                    position = { 0, 0.05, 0 },
                    width = 2400, height = 600,
                    color = Component.ObjectColor.Invisible
                }) .. [[
function packBox(_, _, alt_click)
    if not alt_click then return end

    performOnManager("packCharacter", { player = ]] .. tostring(player) .. [[ })
    self.setState(1)
end]]

        (--[[---@not nil]] data.States)[2].LuaScript = script
        obj.destruct()
        spawnObjectData({ data = data })
    end
end

---@param character gh_Save_Character
---@param callback tts__ObjectCallbackFunction
function Component.placeInactiveCharacter(character, callback)
    local script = Component.scriptOnManager() .. [[
function onCollisionEnter(info)
    if info.collision_object.getName():find("]] .. Names.PlayerMat .. [[") then
        performOnManager("unpackCharacter", { guid = self.getGUID(), character = self.script_state })
    end
end]]

    local characterBoxData = --[[---@type tts__ModelCustomState]] Component.characterBox(--[[---@not nil]] Component.classBox(character.class))
    local characterBox = ObjectState.model({
        type = Object.ModelType.Bag,
        name = character.name,
        description = "Inactive Character Box - Drop on player mat to load - Do NOT alter content",
        mesh = characterBoxData.CustomMesh.MeshURL,
        diffuse = characterBoxData.CustomMesh.DiffuseURL,
        tint = characterBoxData.ColorDiffuse,
        state = character,
        script = script,
        tags = { Component.Tag.InactiveCharacter },
    }, {
        position = Component.safePosition(),
        rotation = { 0, 270, 0 },
        scale = Scales.CharacterBox,
    })

    ---@return tts__NumVectorShape
    local function findFreePosition()
        for i = 1, 3 do
            local zPos = Positions.InactiveCharacter[3] - (i - 1) * 3
            for j = 1, 3 do
                local xPos = Positions.InactiveCharacter[1] + (j - 1) * 3
                local hit = Physics.cast({
                    type = 1,
                    origin = { xPos, 10, zPos },
                    direction = { 0, -1, 0 },
                })

                if hit or hit[1] == nil or hit[1].hit_object.type ~= Object.Type.Bag then
                    return { xPos, Positions.InactiveCharacter[2], zPos }
                end
            end
        end
    end

    spawnObjectData({
        data = characterBox,
        callback_function = function(spawned)
            local pos = findFreePosition()
            spawned.setPosition(pos)
            callback(spawned)
        end,
    })
end

--------------------------------------------------------------------------------
--- General --------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Bag
function Component.lastCharacterBox()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.LastBox)
end

---@return tts__Bag
function Component.beforeLastCharacterBox()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.BeforeLastBox)
end

---@return tts__Object
function Component.map()
    return --[[---@not nil]] getObjectFromGUID(Guid.Map)
end

---@return tts__Bag
function Component.achievementsBag()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.AchievementBag)
end

---@return GUID
function Component.achievementBoardGuid()
    for _, achievementBoard in ipairs(Guids.AchievementBoard) do
        local board = getObjectFromGUID(achievementBoard)
        if board then
            return achievementBoard
        end
    end

    local achievementBag = Component.achievementsBag()
    local achievementBoard = --[[---@not nil]] Search.inContainer(achievementBag, { name = Names.AchievementBoard })
    return achievementBoard.guid
end

---@return tts__VectorShape
function Component.achievementBoardPosition()
    return { 87.26, 2, 26.12 }
end

---@return tts__Object
function Component.partySheet()
    return findComponent("PartySheet", { type = Object.Type.Board, description = "Party Sheet" })
end

---@return nil | tts__Object
function Component.sanctuarySticker()
    return getObjectFromGUID(Guid.SanctuarySticker)
end

--------------------------------------------------------------------------------
--- City-Mat -------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Object
function Component.cityMat()
    return --[[---@not nil]] getObjectFromGUID(Guid.CityMat)
end

---@param snapPoint number
---@return seb_WrappedDeck
local function fromCityMat(snapPoint)
    local deckPosition = Utils.getSnapPosition(Component.cityMat(), snapPoint)
    return WrappedDeck(deckPosition)
end

---@return seb_WrappedDeck
function Component.shopDeck()
    return fromCityMat(CityMatSnapPoints.Shop)
end

---@return seb_WrappedDeck
function Component.rewardItemsDeck()
    return fromCityMat(CityMatSnapPoints.RewardItems)
end

---@param index number
---@return seb_WrappedDeck
function Component.itemDeck(index)
    return fromCityMat(index + 1)
end

--------------------------------------------------------------------------------
--- Deck-Mat -------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Object
function Component.deckMat()
    return --[[---@not nil]] getObjectFromGUID(Guid.DeckMat)
end

---@param snapPoint number
---@return seb_WrappedDeck
local function fromDeckMat(snapPoint)
    local deckPosition = Utils.getSnapPosition(Component.deckMat(), snapPoint)
    return WrappedDeck(deckPosition)
end

---@return seb_WrappedDeck
function Component.questDeck()
    return fromDeckMat(DeckMatSnapPoints.Quests)
end

---@return seb_WrappedDeck
function Component.randomScenarioDeck()
    return fromDeckMat(DeckMatSnapPoints.RandomScenarios)
end

---@param eventDeckInfo gh_EventDeckInfo
---@return tts__Deck
function Component.initialEventDeck(eventDeckInfo)
    local wrappedDeck = fromDeckMat(eventDeckInfo.initialDeckAt)
    return --[[---@type tts__Deck]] wrappedDeck.unwrap()
end

---@param eventDeckInfo gh_EventDeckInfo
---@return seb_WrappedDeck
function Component.eventDeck(eventDeckInfo)
    return fromDeckMat(eventDeckInfo.deckAt)
end

---@return seb_WrappedDeck
function Component.minusOneDeck()
    return fromDeckMat(DeckMatSnapPoints.MinusOneDeck)
end

---@return seb_WrappedDeck
function Component.battleGoalsDeck()
    return fromDeckMat(DeckMatSnapPoints.BattleGoals)
end

--------------------------------------------------------------------------------
--- Event Mat ------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Object
function Component.eventMat()
    return --[[---@not nil]] getObjectFromGUID(Guid.EventsMat)
end

---@param info gh_EventDeckInfo
---@return seb_WrappedDeck
function Component.eventMatDeck(info)
    ---@type tts__Vector
    local position
    if getObjectFromGUID(Guid.OldEventsMat) then
        if info.oldMat then
            position = Utils.getSnapPosition(--[[---@not nil]] getObjectFromGUID(--[[---@not nil]] info.oldMat), 1)
        else
            position = Utils.getSnapPosition(--[[---@not nil]] Component.eventMat(), 1)
        end
    else
        position = Utils.getSnapPosition(--[[---@not nil]] Component.eventMat(), info.atEventMat)
    end

    return WrappedDeck(position)
end

--------------------------------------------------------------------------------
--- Character specific ---------------------------------------------------------
--------------------------------------------------------------------------------

---@param className string
---@return nil | tts__Bag
function Component.classBox(className)
    return --[[---@type nil | tts__Bag]] getObjectFromGUID(Game.class(className).boxGuid)
end

--- Returns the contained character box within a class box for the given class.
---@param classBox tts__Bag | tts__ContainerState
---@return tts__ContainerState
function Component.characterBox(classBox)
    if Object.isObject(classBox) then
        return --[[---@type tts__ContainerState]] (--[[---@type tts__Bag]] classBox).getData().ContainedObjects[1]
    end
    return --[[---@type tts__ContainerState]] (--[[---@type tts__ContainerState]] classBox).ContainedObjects[1]
end

---@param object seb_Object_Identifiable
function Component.isPlayerMat(object)
    return Object.name(object):find(Names.PlayerMat) ~= nil
end

---@param object seb_Object_Identifiable
function Component.isAbilityDeck(object)
    if not (Object.isSimple(object) or Object.isDeck(--[[---@type seb_Object]] object)) then
        return false
    end
    local name = Object.name(object)
    return name:find(Names.AbilityDeck) ~= nil or name:find(Names.StartingAbilityDeck) ~= nil
end

---@param player number
---@return seb_WrappedDeck
function Component.abilityDeck(player)
    local abilityDeck = --[[---@type tts__Deck]] Search.inZone(Component.playerZone(player), { name = Names.AbilityDeck })
    return WrappedDeck(abilityDeck)
end

---@param player number
---@return tts__Vector
function Component.abilityDeckPosition(player)
    return relativeToZone(player, Positions.AbilityDeck)
end

---@param object seb_Object
---@param className string
function Component.isAbilityCardForClass(object, className)
    local name = Object.name(object)

    if not Object.isCard(object)
            or not Object.description(object):find(className)
            or name:find(Names.AttachModifierCard) then
        return false
    end

    local cardName = StringUtil.replace(name, "[%(%)]%d%d[%)%(]")
    local nearest, _ = Game.nearestAbility(className, cardName)
    return nearest ~= nil
end

---@param className string
---@param abilityName string
function Component.isStartingAbility(className, abilityName)
    local ability = --[[---@not nil]] Game.ability(className, abilityName)
    return ability.level == 1 or ability.level == "X"
end

---@param class string
---@param abilityCard seb_Object
---@return string
function Component.getAbilityName(class, abilityCard)
    local cardName = StringUtil.replace(Object.name(abilityCard), "%s?[%(%)]%d+[%)%(]")
    return --[[---@not nil]] (--[[---@not nil]] Game.ability(class, cardName)).name
end

---@return tts__Bag[]
function Component.inactiveCharacters()
    return --[[---@type tts__Bag[] ]] getObjectsWithTag(Component.Tag.InactiveCharacter)
end

---@return tts__Bag[]
function Component.packedCharacters()
    return --[[---@type tts__Bag[] ]] TableUtil.filter(getObjects(), function(obj)
        return Object.isBag(obj) and obj.getDescription() == Names.InactiveCharacter
    end)
end

---@param player number
---@param positionName gh_Save_Character_Item_Position
function Component.itemPosition(player, positionName)
    if positionName then
        local snapPoint = PlayerMatItemPositions[positionName]
        if snapPoint then
            return Utils.getSnapPosition(Component.playerMat(player), snapPoint)
        end
    end
    return relativeToZone(player, Positions.ItemUnequipped)
end

---@param playerMat tts__Object
---@param object tts__Object | tts__ObjectState
---@return gh_Save_Character_Item_Position
function Component.itemPositionName(playerMat, object)
    for name, snap in pairs(PlayerMatItemPositions) do
        if Utils.getSnapPosition(playerMat, snap) == Object.position(object) then
            return name
        end
    end

    return "Unequipped"
end

--------------------------------------------------------------------------------
--- Player specific ------------------------------------------------------------
--------------------------------------------------------------------------------

---@return number
function Component.playerCount()
    return 4
end

---@return GUID[]
function Component.playerZones()
    return Guids.Zones
end

---@param player number
---@return tts__ScriptingTrigger
function Component.playerZone(player)
    return --[[---@type tts__ScriptingTrigger]] getObjectFromGUID(Guids.Zones[player])
end

--- Returns all objects of the given player. Only objects which center is within the planar bounds of the player zone
--- are returned. This avoids duplicated objects that overlap multiple zones.
---@param player number
---@return tts__Object[]
function Component.playerObjects(player)
    local zone = Component.playerZone(player)
    return TableUtil.filter(zone.getObjects(),
            function(object) return Utils.isCenterInZone(zone, object) end)
end

---@param player number
---@param object tts__Object
---@return boolean
function Component.isPlayerObject(player, object)
    local zone = Component.playerZone(player)
    return Utils.isCenterInZone(zone, object)
end

---@param player number
---@return tts__Object[]
function Component.playerHand(player)
    return Player[Component.PlayerColors[player]].getHandObjects()
end

---@param playerMat tts__ObjectState
function Component.adjustPlayerMatSnapPoints(playerMat)
    ---@param snaps tts__ObjectState_SnapPoint[]
    ---@param zPosition number
    local function addSnapPoint(snaps, zPosition)
        table.insert(snaps, {
            Position = { x = 1.52, y = 0.1, z = zPosition },
            Tags = {},
        })
    end

    local snaps = --[[---@not nil]] playerMat.AttachedSnapPoints
    addSnapPoint(snaps, -0.72)
    addSnapPoint(snaps, -0.24)
    addSnapPoint(snaps, 0.24)
    addSnapPoint(snaps, 0.72)

    if playerMat.States then
        for _, state in pairs(--[[---@not nil]] playerMat.States) do
            Component.adjustPlayerMatSnapPoints(state)
        end
    end
end

---@param player number
---@param callback fun(): void
function Component.loadPlayer(player, callback)
    local playerZoneGuid = Guids.Zones[player]
    Component.playerButton(player).call("addPlayer")
    Utils.waitForObjectInZone(playerZoneGuid, { name = Names.PlayerMat }, function()
        callback()
    end)
end

---@param player number
---@param characterBoxData tts__BagState
function Component.placeCharacterBox(player, characterBoxData)
    spawnObjectData({
        data = characterBoxData,
        position = relativeToZone(player, Positions.CharacterBox),
    })
end

---@param player number
---@param character gh_Save_Character
---@param object tts__ObjectState
---@param component gh_PlayerComponent
function Component.placePlayerComponent(player, character, object, component)
    local position
    if component.snapPoint then
        position = Utils.getSnapPosition(Component.playerMat(player), --[[---@not nil]] component.snapPoint)
    else
        position = relativeToZone(player, --[[---@not nil]] component.position)
    end

    spawnObjectData({
        data = object,
        position = position:add({ x = 0, y = 1, z = 0 }),
        rotation = component.rotation,
        callback_function = function(obj)
            if component.event then
                Wait.time(function()
                    EventManager.triggerEvent(--[[---@not nil]] component.event, obj, player, character)
                end, 1)
            end
        end,
    })
end

---@param player number
---@param character gh_Save_Character
---@param component gh_PlayerComponent
function Component.placeExtraPlayerComponents(player, character, component)
    ---@type nil | tts__Bag
    local fromBag
    if component.playerBag then
        local bagGuid = (--[[---@not nil]] component.playerBag)[player]
        fromBag = --[[---@type tts__Bag]] getObjectFromGUID(bagGuid)
    elseif component.bag then
        fromBag = --[[---@type tts__Bag]] getObjectFromGUID(--[[---@not nil]] component.bag)
    end

    if fromBag then
        local object = (--[[---@not nil]] fromBag).getData().ContainedObjects[1]
        Component.placePlayerComponent(player, character, object, component)
    end
end

---@return GUID[]
function Component.playerButtons()
    return Guids.AddPlayers
end

---@param index number
---@return tts__Object
function Component.playerButton(index)
    return --[[---@not nil]] getObjectFromGUID(Guids.AddPlayers[index])
end

---@param player number
---@return tts__Object
function Component.playerMat(player)
    return --[[---@not nil]] Search.inZone(Component.playerZone(player), { name = Names.PlayerMat, isPattern = true })
end

---@param player number
---@return nil | tts__Object
function Component.characterMat(player)
    return Search.inZone(Component.playerZone(player), { name = Names.CharacterMat })
end

---@param player number
---@return tts__Object
function Component.characterSheet(player)
    return --[[---@not nil]] Search.inZone(Component.playerZone(player), { name = Names.CharacterSheet })
end

---@param player number
---@return tts__Deck
function Component.attackModifiers(player)
    local search = { name = Names.AttackModifierDeck, description = "Player", isPattern = true }
    return --[[---@type tts__Deck]] Search.inZone(Component.playerZone(player), search)
end

---@param player number
---@return seb_WrappedDeck
function Component.additionalAttackModifiers(player)
    for _, obj in ipairs(Component.playerZone(player).getObjects()) do
        if obj.type == Object.Type.Deck
                and obj.getName() == Names.AttackModifierDeck
                and obj.getDescription() ~= "Player " .. player then
            return WrappedDeck(--[[---@type tts__Deck]] obj)
        end
    end
end

---@param name string
---@return string
function Component.modifierNamePattern(name)
    return "^" .. Names.AttachModifierCard .. " " .. StringUtil.escapePattern(name) .. "$"
end

---@param player number
---@return nil | string
function Component.playerClass(player)
    local characterMat = Component.characterMat(player)
    if characterMat then
        return (--[[---@not nil]] characterMat).getDescription()
    end
    return nil
end

--------------------------------------------------------------------------------
--- Specific cards -------------------------------------------------------------
--------------------------------------------------------------------------------

--- Returns true if the given object is an item card.
---@param object seb_Object
function Component.isItemCard(object)
    return Object.isCard(object)
            and (Component.isItemCardDescription(Object.description(object))
            or Game.Items.List[Object.name(object)] ~= nil)
end

--- Returns true if the given item card object is an item from the rewards or item design deck.
---@param item seb_Object
---@param prosperityLevel nil | number
function Component.isRewardItemCard(item, prosperityLevel)
    if not Component.isItemCard(item) then
        return false
    end

    prosperityLevel = prosperityLevel or 1
    if Object.description(item) == "" then
        local itemInfo = Game.Items.List[Object.name(item)]
        return itemInfo.reward ~= nil or itemInfo.prosperity > prosperityLevel
    else
        local description = Object.description(item)
        description = StringUtil.replace(description, "red")
        description = StringUtil.replace(description, "blue")
        return tonumber(description) > Game.Items.Prosperity[--[[---@not nil]] prosperityLevel]
    end
end

--- Returns true if the given object description is a possible item card's description.
function Component.isItemCardDescription(description)
    return description:find("^%d+$")
            or description:find("^%d+ red$")
            or description:find("^%d+ blue$")
end

---@param object seb_Object
function Component.isPersonalQuestCard(object)
    local customDeck = (--[[---@type tts__DeckCustomState]] Object.data(object)).CustomDeck
    if not Object.isCard(object) or not customDeck then
        return false
    end

    for key, _ in pairs(customDeck) do
        return TableUtil.contains(DeckIds.Quests, key)
    end
end

---@param object seb_Object
---@return nil | gh_Game_Quest_Info
function Component.getQuestInfo(object)
    local cardId = Object.data(object).CardID
    local cardIndex = tonumber(tostring(cardId):sub(-2, -1))
    for name, quest in pairs(Game.Quests) do
        if quest.index == cardIndex then
            return { name = name, index = quest.index, number = quest.number }
        end
    end

    return nil
end

---@param customDeck number[]
---@param index number
---@return number
local function getCardId(customDeck, index)
    local customDeckId = customDeck[#customDeck]
    return --[[---@not nil]] tonumber(string.format("%d%02d", customDeckId, index))
end

---@param index number
---@return number
function Component.getQuestCardId(index)
    return getCardId(DeckIds.Quests, index)
end

---@param index number
---@return number
function Component.getScenarioCardId(index)
    return getCardId(DeckIds.RandomScenarios, index)
end

---@param object nil | tts__Object
---@param name string
local function verifyObject(object, name)
    assert(object ~= nil, name .. " is missing ")
end

---@param container tts__Container
---@param content GUID
---@param name string
local function verifyContent(container, content, name)
    assert(getObjectFromGUID(content)
            or Search.inContainer(container, { guid = content }),
            name .. " is missing")
end

---@param object tts__Object
---@param tableName string
---@param name string
local function verifyTable(object, tableName, name)
    assert(object.getTable(tableName), name .. " is missing")
end

--- Verifies that the script can actually run, by checking if needed objects exists.
function Component.verifyLoad()
    local gamebox = Component.gamebox()
    verifyObject(gamebox, "Gamebox")
    verifyContent(gamebox, Guid.LockedClasses, "Locked classes")
    verifyContent(gamebox, Guid.ScenarioBook, "Scenario book")
    verifyContent(gamebox, Guid.RuleBook, "Rule book")
    verifyContent(gamebox, Guid.OpeningConditions, "Opening Conditions")
    verifyContent(gamebox, Guid.RetirementSheet, "Retirement Sheet")
    verifyContent(gamebox, Guid.TownRecords, "Town Records")

    local map = Component.map()
    verifyObject(map, "Map")
    verifyTable(map, "tableML", "Scenario information")
    verifyTable(map, "Pros", "Prosperity information")

    verifyObject(Component.achievementsBag(), "Achievements bag")
    verifyObject(Component.deckMat(), "Deck Mat")
    --verifyObject(Component.minusOneDeck(), "-1 Deck")
    verifyObject(Component.cityMat(), "City Mat")
    verifyObject(Component.eventMat(), "Events Mat")
    verifyObject(Component.partySheet(), "Party Sheet")
    for i, zone in pairs(Guids.Zones) do
        verifyObject(getObjectFromGUID(zone), "Player zone " .. i)
    end
    for i, button in pairs(Component.playerButtons()) do
        verifyObject(getObjectFromGUID(button), "Add Player button " .. i)
    end
end

--------------------------------------------------------------------------------
--- Discard --------------------------------------------------------------------
--------------------------------------------------------------------------------

---@param card tts__Card
---@param player number
---@param keepDiscarded boolean
function Component.discardAttackModifier(card, player, keepDiscarded)
    if keepDiscarded then
        local position = relativeToZone(player, Positions.AttackModifierDiscard)
        local discarded = WrappedDeck(position)
        discarded.setName("Discarded Attack Modifiers")
        discarded.putObject(card)
    else
        card.destruct()
    end
end

---@param card tts__Card
---@param keepDiscarded boolean
function Component.discardScenario(card, keepDiscarded)
    if keepDiscarded then
        local discarded = WrappedDeck(Vector(Positions.ScenarioDiscard))
        discarded.setName("Discarded Random Dungeons")
        discarded.putObject(card)
    else
        card.destruct()
    end
end

---@param card tts__Card
---@param keepDiscarded boolean
function Component.discardTreasure(card, keepDiscarded)
    if keepDiscarded then
        local discarded = WrappedDeck(Vector(Positions.LootedTreasures))
        discarded.setName("Looted Treasures")
        discarded.putObject(card)
    else
        card.destruct()
    end
end

---@param card tts__Card
---@param keepDiscarded boolean
function Component.discardQuest(card, keepDiscarded)
    if keepDiscarded then
        local discarded = WrappedDeck(Vector(Positions.CompletedQuests))
        discarded.setName("Completed Quests")
        discarded.putObject(card)
    else
        card.destruct()
    end
end

---@return string
function Component.scriptOnManager()
    return [[
function performOnManager(functionName, parameters)
    local withTag = getObjectsWithTag("]] .. Component.Tag.CampaignManager .. [[")
    if withTag == nil or #withTag == 0 then
        print("Can not find the campaign manager! :-(")
    else
        withTag[1].call(functionName, parameters)
    end
end
]]
end

---@param parameters tts__CreateButtonParameters
---@return string
function Component.scriptButton(parameters)
    ---@param tab nil | table
    ---@return string
    local function tableString(tab)
        if not tab then return "nil"
        else return TableUtil.dump(--[[---@not nil]] tab) end
    end

    return [[
function onLoad()
    self.createButton({
        label = "]] .. (parameters.label or "") .. [[",
        tooltip = "]] .. (parameters.tooltip or "") .. [[",
        function_owner = self,
        click_function = "]] .. parameters.click_function .. [[",
        position = ]] .. tableString(parameters.position) .. [[,
        rotation = ]] .. tableString(parameters.rotation) .. [[,
        scale = ]] .. tableString(parameters.scale) .. [[,
        width = ]] .. tostring(parameters.width) .. [[,
        height = ]] .. tostring(parameters.height) .. [[,
        font_size = ]] .. tostring(parameters.font_size) .. [[,
        color = ]] .. tableString(parameters.color) .. [[,
        font_color = ]] .. tableString(parameters.font_color) .. [[,
    })
end
]]
end

return Component
