local Logger = require("sebaestschjin-tts.Logger")
local Object = require("sebaestschjin-tts.Object")
local ObjectState = require("sebaestschjin-tts.ObjectState")
local Search = require("sebaestschjin-tts.Search")
local StringUtil = require("sebaestschjin-tts.StringUtil")
local TableUtil = require("sebaestschjin-tts.TableUtil")
local Utils = require("sebaestschjin-tts.Utils")
local WrappedDeck = require("sebaestschjin-tts.WrappedDeck")

local Game = require("gloomhaven-campaign-manager.Game")
local Options = require("gloomhaven-campaign-manager.Options")
local Task = require("gloomhaven-campaign-manager.Task")

---
--- Handles everything about the different game components required to load and save a Gloomhaven-Campaign. Has methods
--- to locate and place those components.
---
local Component = {}

---@type table<string, string>
Component.Tag = {
    CampaignManager = "Gloomhaven - Campaign Manager",
    InactiveCharacter = "Gloomhaven - Inactive Character",
}

--- A list of GUIDs of relevant components.
local Guid = {
    Gamebox = "346ed5",
    ForgottenCirclesBox = "5e28e8",
    LockedClasses = "1e6549",
    ScenarioBook = "f3404a",
    RuleBook = "c9d3f5",
    OpeningConditions = "30ae8e",
    RetirementSheet = "a30c94",
    TownRecords = "a6c771",
    TreasureDeck = "284016",
    PartySheet = "6d3de2",
    LastBox = "fdef02", -- tinkerer
    BeforeLastBox = "ec1d2a", -- cragheart
    Map = "9cc037",
    AchievementBag = "3ea749", -- Bag containing the Achievement board
    SanctuarySticker = "800847",
    DeckMat = "a75fcd",
    CityEventsDeckInitial = "759349",
    CityEventsDeck = "f13efd",
    RoadEventsDeckInitial = "83de73",
    RoadEventsDeck = "f08b69",
    CityMat = "f3ffb7",
    EventsMat = "b53fb2",
    OldEventsMat = "41393b",
    FantasySetupScripts = "75ab50",
    HpTrackerBag = "6c775e",
    XpTrackerBag = "0625c4",
}

--- A list of components with multiple GUIDs (e.g. where newer versions have different GUIDs) or where multiple objects exist.
local Guids = {
    Zones = --[[---@type GUID[] ]] { "49a4e0", "dac936", "62cd94", "963318" },
    Zones5Players = --[[---@type GUID[] ]] { "49a4e0", "dac936", "62cd94", "963318", "aa25be" },
    AddPlayers = --[[---@type GUID[] ]] { "3f0cda", "4d61da", "f98ff8", "d0f661" },
    AddPlayers5Players = --[[---@type GUID[] ]] { "d0f661", "4d61da", "f98ff8", "3f0cdb", "3f0cda" },
    RemovePlayers = --[[---@type GUID[] ]] { "bdfe0a", "a93090", "86087f", "9749e9" },
    RemovePlayers5Players = --[[---@type GUID[] ]] { "6ded50", "a93090", "86087f", "bdfe0b", "bdfe0a" },
    AchievementBoard = --[[---@type GUID[] ]] { "43d5b8", "546b57" },
    ModifierDecks = --[[---@type GUID[] ]] { "bb85b9", "d23231", "74238d", "20d00f" }
}

--- A list of CustomDeck-IDs to identify cards. May have multiple entries if newer version have other IDs.
---@type table<string, number[]>
local DeckIds = {
    Quests = { 1753, 1997 },
    RandomScenarios = { 1930 },
}

--- A list of names to identify components by.
local Names = {
    CharacterMat = "Character Mat",
    AbilityDeck = "Advanced Abilities",
    StartingAbilityDeck = "Starting Abilities",
    AttackModifierDeck = "Attack Modifiers",
    AchievementBoard = "Achievements",
    InactiveCharacter = "Repacked",
    PlayerMat = "Player Mat",
    CharacterSheet = "Character Sheet",
    AttackModifierCard = "Attack Modifier",
    Summons = "Summons",
    Trackers = "Trackers",
}

local TableHigh = 0.65

--- A list of positions where components should be placed.
local Positions = {
    -- relative to player zone
    QuestCard = --[[---@type tts__NumVectorShape]] { 1, 2, -19 },
    ItemUnequipped = --[[---@type tts__NumVectorShape]] { -7, 2, -7 },
    Hand = --[[---@type tts__NumVectorShape]] { 0, 3, 5 },
    SecondHand = --[[---@type tts__NumVectorShape]] { 0, 3, -2 },
    AbilityDeck = --[[---@type tts__NumVectorShape]] { -3.2, -2.26, -15.17 },
    AttackModifierDiscard = --[[---@type tts__NumVectorShape]] { -4.69, 2, 26.5 },
    CharacterSheet = --[[---@type tts__NumVectorShape]] { 6.31, 0, -17 },
    Figurine = --[[---@type tts__NumVectorShape]]  { 0, 0, 23.23 },
    AttackModifierDeck = --[[---@type tts__NumVectorShape]] { -7, 0, -14.27 },
    CharacterBox = --[[---@type tts__NumVectorShape]] { 0.62, 0, -15.77 },
    PlayerMat = { 0, -1, 17.23 },
    CharacterMat = { 2.18, -3, 16.95 },
    ExtraRules = --[[---@type tts__NumVectorShape]] { 6.31, 0, -28 },
    ExtraTokens = --[[---@type tts__NumVectorShape]] { 6.31, 0, -11 },
    -- absolute
    AchievementBoard = --[[---@type tts__NumVectorShape]] { 87.26, 2, 26.12 },
    OpeningConditions = --[[---@type tts__NumVectorShape]] { 65.19, 1.70, -29.55 },
    RetirementSheet = --[[---@type tts__NumVectorShape]] { 77.88, 1.70, -33.34 },
    ScenarioBook = --[[---@type tts__NumVectorShape]] { 63.88, 2, 37.89 },
    RuleBook = --[[---@type tts__NumVectorShape]] { -64.31, 2, -41.68 },
    TownRecords = --[[---@type tts__NumVectorShape]] { 73.94, 2, 34.10 },
    TreasureDeck = --[[---@type tts__NumVectorShape]] { -75, 2, -5.3 },
    ScenarioDiscard = --[[---@type tts__NumVectorShape]] { 56.0, 2, -1.52 },
    CompletedQuests = --[[---@type tts__NumVectorShape]] { 56.0, 2, -12.5 },
    EventDiscardCity = --[[---@type tts__NumVectorShape]] { 56.0, 2, 1.8 },
    EventDiscardRoad = --[[---@type tts__NumVectorShape]] { 56.0, 2, 9.1 },
    LootedTreasures = --[[---@type tts__NumVectorShape]]{ -68, 2, 17 },
    InactiveCharacter = --[[---@type tts__NumVectorShape]] { -66.29, 1.6, -23.91 },
}

local Scales = {
    InactiveCharacterZone = { 8.14, 10, 8.63 },
    CharacterBox = { 0.48, 0.48, 0.48 },
}

--- A list of snap points on the player mat, e.g. for item slots.
---@type table<gh_Save_Character_Item_Position, number>
local PlayerMatItemPositions = {
    Head = 15,
    Armor = 16,
    HandLeft = 17,
    HandRight = 18,
    Boots = 19,
    Bag1 = 12,
    Bag2 = 13,
    Bag3 = 14,
    Bag4 = 22,
    Bag5 = 23,
    Bag6 = 24,
    Bag7 = 25,
    Active1 = 6,
    Active2 = 7,
    Active3 = 8,
    Active4 = 9,
}

--- A list of snap points on the deck mat containing different decks.
---@type table<string, number>
local DeckMatSnapPoints = {
    MinusOneDeck = 3,
    RoadEventsInitial = 4,
    RoadEvents = 5,
    CityEventsInitial = 6,
    CityEvents = 7,
    RandomScenarios = 8,
    Quests = 11,
    BattleGoals = 12,
}

--- A list of snap points on the city deck mat containing different decks.
local CityMatSnapPoints = {
    Shop = 1,
    RewardItems = 13,
}

--- Player color associated with each player
---@type tts__PlayerColor[]
Component.PlayerColors = { "Red", "White", "Blue", "Green", "Purple" }

--- Information about an event deck.
---@shape gh_EventDeckInfo
---@field name string
---@field initialDeckAt number
---@field deckAt number
---@field atEventMat number
---@field count number
---@field expansionCount number
---@field oldMat nil | GUID
---@field discardPosition tts__NumVectorShape

---@type table<string, gh_EventDeckInfo>
Component.EventDecks = {
    ["city"] = {
        name = "City Events",
        initialDeckAt = DeckMatSnapPoints.CityEventsInitial,
        deckAt = DeckMatSnapPoints.CityEvents,
        atEventMat = 2,
        count = 81,
        expansionCount = 9,
        discardPosition = Positions.EventDiscardCity,
    },
    ["road"] = {
        name = "Road Events",
        initialDeckAt = DeckMatSnapPoints.RoadEventsInitial,
        deckAt = DeckMatSnapPoints.RoadEvents,
        atEventMat = 1,
        oldMat = Guid.OldEventsMat,
        count = 69,
        expansionCount = 2,
        discardPosition = Positions.EventDiscardRoad,
    },
}

---@shape gh_PlayerComponent
---@field name nil | string
---@field class nil | boolean
---@field snapPoint nil | number
---@field position nil | tts__VectorShape
---@field rotation nil | tts__VectorShape
---@field locked nil | boolean
---@field playerBag nil | GUID[]
---@field bag nil | GUID
---@field event nil | string

---@type table<string, gh_PlayerComponent>
Component.PlayerComponent = {
    CharacterMat = {
        name = Names.CharacterMat,
        position = Positions.CharacterMat,
        locked = true,
    },
    Figurine = {
        class = true,
        position = Positions.Figurine,
        rotation = { 0, 0, 0 },
        event = Task.Event.Character.Figurine,
    },
    Summons = {
        name = Names.Summons,
        snapPoint = 2,
    },
    Trackers = {
        name = Names.Trackers,
        snapPoint = 1,
    },
    AttackModifierDeck = {
        name = Names.AttackModifierDeck,
        position = Positions.AttackModifierDeck,
        rotation = { 0, 180, 0 },
        event = Task.Event.Character.AttackModifiers,
    },
}

---@type table<string, gh_PlayerComponent>
Component.ExtraPlayerComponent = {
    Hp = {
        snapPoint = 10,
        rotation = { 0, 180, 0 },
        bag = Guid.HpTrackerBag,
        event = Task.Event.Character.HpTrack,
    },
    Xp = {
        snapPoint = 11,
        rotation = { 0, 180, 0 },
        bag = Guid.XpTrackerBag,
    },
    AttackModifierPlayerDeck = {
        snapPoint = 4,
        rotation = { 0, 180, 180 },
        playerBag = Guids.ModifierDecks,
        event = Task.Event.Character.AttackModifiersPlayer,
    },
}

Component.ObjectColor = {
    Red = --[[---@type tts__ColorShape]] { 0.82, 0.25, 0.18, 1 },
    Yellow = --[[---@type tts__ColorShape]] { 0.75, 0.67, 0.56, 1 },
    Black = --[[---@type tts__ColorShape]] { 0.18, 0.047, 0.047, 1 },
    White = --[[---@type tts__ColorShape]] { 0.812, 0.70, 0.60, 1 },
    Invisible = --[[---@type tts__ColorShape]] { 0, 0, 0, 0 },
}

---@overload fun(guidName: string, search: seb_Search_Full): tts__Object
---@param guidName string
---@param search seb_Search_Full
---@param isError boolean
---@return tts__Object
local function findComponent(guidName, search, isError)
    if isError == nil then
        isError = true
    end
    local guid = Guid[guidName]

    local byId = getObjectFromGUID(guid)
    if byId ~= nil then
        return --[[---@not nil]] byId
    end

    local bySearch = Search.inAllObjects(search)
    if bySearch ~= nil then
        Guid[guidName] = (--[[---@not nil]] bySearch).getGUID()
        return --[[---@not nil]] bySearch
    else
        if isError then
            Logger.error("Fatal error! Can not find component %s", guidName)
        end
    end
end

---@return boolean
local function is5PlayerVersion()
    return getObjectFromGUID(Guids.Zones5Players[5]) ~= nil
end

---@return GUID[]
local function addPlayerButtonsGuids()
    if is5PlayerVersion() then
        return Guids.AddPlayers5Players
    end
    return Guids.AddPlayers
end

---@return GUID[]
local function removePlayerButtonsGuids()
    if is5PlayerVersion() then
        return Guids.RemovePlayers5Players
    end
    return Guids.RemovePlayers
end

--------------------------------------------------------------------------------
--- Positioning ----------------------------------------------------------------
--------------------------------------------------------------------------------

---@param player number
---@param position tts__VectorShape
---@return tts__Vector
local function relativeToZone(player, position)
    return Component.playerZone(player).getPosition() + Vector(position)
end

local MaxColumn = 40
local positionCounter = 0

---@overload fun(): tts__VectorShape
---@param elevation nil | number
---@return tts__Vector
function Component.safePosition(elevation)
    positionCounter = positionCounter + 1
    local offsetZ = math.floor(positionCounter / MaxColumn)
    return Vector(-23 + (positionCounter * 3), TableHigh + (elevation or 0), -85 - offsetZ)
end

---@param player number
---@param target number
---@return tts__Vector
function Component.handPosition(player, target)
    if target == 1 then
        return relativeToZone(player, Positions.Hand)
    end
    if target == 2 then
        return relativeToZone(player, Positions.SecondHand)
    end
end

---@param player number
---@return tts__Vector
function Component.questPosition(player)
    return relativeToZone(player, Positions.QuestCard)
end

---@param player number
---@return tts__Vector
function Component.characterSheetPosition(player)
    return relativeToZone(player, Positions.CharacterSheet)
end

--------------------------------------------------------------------------------
--- Gamebox-Content ------------------------------------------------------------
--------------------------------------------------------------------------------

---@overload fun(guid: GUID, position: tts__VectorShape)
---@param guid GUID
---@param position tts__VectorShape
---@param savefile gh_Savefile
---@param event nil | string
local function takeFromGamebox(guid, position, savefile, event)
    local object = getObjectFromGUID(guid)
    if object == nil then
        Component.gamebox().takeObject({
            guid = guid,
            smooth = false,
            position = position,
            rotation = { 0, 180, 0 },
            callback_function = function()
                if event then
                    Wait.frames(function()
                        Task.completeLoad(--[[---@not nil]] event, savefile)
                    end, 1)
                end
            end,
        })
    elseif event then
        Task.completeLoad(--[[---@not nil]] event, savefile)
    end
end

---@return tts__Bag
function Component.gamebox()
    return --[[---@type tts__Bag]] findComponent("Gamebox",
            { type = Object.Type.Bag, name = "Unlockable Content" })
end

---@overload fun(): tts__Bag
---@param required boolean
---@return nil | tts__Bag
function Component.forgottenCirclesBox(required)
    if required == nil then
        required = true
    end
    return --[[---@type tts__Bag]] findComponent("ForgottenCirclesBox",
            { type = Object.Type.Bag, name = "Gloomhaven: Forgotten Circles" }, required)
end

---@return tts__Bag
function Component.lockedClasses()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.LockedClasses)
end

---@return nil | tts__Deck
function Component.treasureDeck()
    return --[[---@type nil | tts__Deck]] getObjectFromGUID(Guid.TreasureDeck)
end

---@return nil | (tts__ObjectState, number)
function Component.treasureDeckData()
    return Search.inContainedObjects(Component.gamebox(), { guid = Guid.TreasureDeck })
end

---@return nil | tts__Object
function Component.retirementSheet()
    return getObjectFromGUID(Guid.RetirementSheet)
end

---@return nil | tts__Object
function Component.openingConditions()
    return findComponent("OpeningConditions", { name = "Opening Conditions" }, false)
end

function Component.placeScenarioBook()
    takeFromGamebox(Guid.ScenarioBook, Positions.ScenarioBook)
end

function Component.placeRuleBook()
    takeFromGamebox(Guid.RuleBook, Positions.RuleBook)
end

---@param savefile gh_Savefile
function Component.placeTreasureDeck(savefile)
    takeFromGamebox(Guid.TreasureDeck, Positions.TreasureDeck, savefile, Task.Event.Placed.Treasure)
end

---@param savefile gh_Savefile
function Component.placeLockedCharacter(savefile)
    takeFromGamebox(Guid.LockedClasses, Component.safePosition(), savefile, Task.Event.Placed.LockedCharacters)
end

---@param savefile gh_Savefile
function Component.placeOpeningConditions(savefile)
    takeFromGamebox(Guid.OpeningConditions, Positions.OpeningConditions, savefile, Task.Event.Placed.OpeningConditions)
end

---@param savefile gh_Savefile
function Component.placeRetirementSheet(savefile)
    takeFromGamebox(Guid.RetirementSheet, Positions.RetirementSheet, savefile, Task.Event.Placed.RetirementSheet)
end

function Component.placeTownRecords()
    Component.gamebox().takeObject({
        guid = Guid.TownRecords,
        position = Positions.TownRecords,
        rotation = { 0, 180, 0 },
        smooth = false
    })
end

---@param savefile gh_Savefile
function Component.placeSanctuarySticker(savefile)
    Component.map().call('unseal')
    Utils.waitForObject(Guid.SanctuarySticker, function()
        Task.completeLoad(Task.Event.Placed.SanctuarySticker, savefile)
    end)
end

function Component.replacePlayerButtons()
    Logger.info("Replacing the functions of the 'Add Player' buttons with custom functionality.")

    ---@param player number
    ---@return string
    local function createScript(player)
        local script = Component.scriptOnManager() ..
                Component.scriptButton({
                    tooltip = "Right click to Remove Player!",
                    click_function = "packBox",
                    position = { 0, 0.05, 0 },
                    width = 2400, height = 600,
                    color = Component.ObjectColor.Invisible
                }) .. [[
function packBox(_, _, alt_click)
    if not alt_click then return end

    if performOnManager("packCharacter", { player = ]] .. tostring(player) .. [[ }) then
        self.setState(1)
    end
end]]
        return script
    end

    ---@param player number
    ---@param buttonGuid string
    ---@param isAddButton boolean
    local function replaceButton(player, buttonGuid, isAddButton)
        local button = getObjectFromGUID(buttonGuid)
        if not button then
            return
        end

        local data = (--[[---@not nil]] button).getData()
        local script = createScript(player)

        if isAddButton then
            (--[[---@not nil]] data.States)[2].LuaScript = script
        else
            data.LuaScript = script
        end

        Object.respawn(data)
    end

    for i, addGuid in ipairs(addPlayerButtonsGuids()) do
        replaceButton(i, addGuid, true)
    end

    for i, removeGuid in ipairs(removePlayerButtonsGuids()) do
        replaceButton(i, removeGuid, false)
    end
end

---@param character gh_Save_Character
---@param callback tts__ObjectCallbackFunction
function Component.placeInactiveCharacter(character, callback)
    local script = Component.scriptOnManager() .. [[
function onCollisionEnter(info)
    if info.collision_object.getName():find("]] .. Names.PlayerMat .. [[") then
        performOnManager("unpackCharacter", { guid = self.getGUID(), character = self.script_state })
    end
end]]

    local characterBoxData = --[[---@type tts__ModelCustomState]] Component.characterBox(--[[---@not nil]] Component.classBox(character.class))
    local characterBox = ObjectState.model({
        type = Object.ModelType.Bag,
        name = character.name,
        description = "Inactive Character Box - Drop on player mat to load - Do NOT alter content",
        mesh = characterBoxData.CustomMesh.MeshURL,
        diffuse = characterBoxData.CustomMesh.DiffuseURL,
        tint = characterBoxData.ColorDiffuse,
        state = character,
        script = script,
        tags = { Component.Tag.InactiveCharacter },
    }, {
        position = Component.safePosition(),
        rotation = { 0, 270, 0 },
        scale = Scales.CharacterBox,
    })

    ---@return tts__NumVectorShape
    local function findFreePosition()
        for i = 1, 3 do
            local zPos = Positions.InactiveCharacter[3] - (i - 1) * 3
            for j = 1, 3 do
                local xPos = Positions.InactiveCharacter[1] + (j - 1) * 3
                local hit = Physics.cast({
                    type = 1,
                    origin = { xPos, TableHigh + 1, zPos },
                    direction = { 0, 1, 0 },
                })

                if TableUtil.isEmpty(hit) then
                    return { xPos, Positions.InactiveCharacter[2], zPos }
                end
            end
        end
    end

    spawnObjectData({
        data = characterBox,
        callback_function = function(spawned)
            local pos = findFreePosition()
            spawned.setPosition(pos)
            callback(spawned)
        end,
    })
end

--------------------------------------------------------------------------------
--- General --------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Bag
function Component.lastCharacterBox()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.LastBox)
end

---@return tts__Bag
function Component.beforeLastCharacterBox()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.BeforeLastBox)
end

---@return tts__Object
function Component.map()
    return --[[---@not nil]] getObjectFromGUID(Guid.Map)
end

---@return tts__Bag
function Component.achievementsBag()
    return --[[---@type tts__Bag]] getObjectFromGUID(Guid.AchievementBag)
end

---@return GUID
function Component.achievementBoardGuid()
    for _, achievementBoard in ipairs(Guids.AchievementBoard) do
        local board = getObjectFromGUID(achievementBoard)
        if board then
            return achievementBoard
        end
    end

    local achievementBag = Component.achievementsBag()
    local achievementBoard = --[[---@not nil]] Search.inContainer(achievementBag, { name = Names.AchievementBoard })
    return achievementBoard.guid
end

---@return tts__VectorShape
function Component.achievementBoardPosition()
    return { 87.26, 2, 26.12 }
end

---@return tts__Object
function Component.partySheet()
    return findComponent("PartySheet", { type = Object.Type.Board, description = "Party Sheet" })
end

---@return nil | tts__Object
function Component.sanctuarySticker()
    return getObjectFromGUID(Guid.SanctuarySticker)
end

--------------------------------------------------------------------------------
--- City-Mat -------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Object
function Component.cityMat()
    return --[[---@not nil]] getObjectFromGUID(Guid.CityMat)
end

---@param snapPoint number
---@return seb_WrappedDeck
local function fromCityMat(snapPoint)
    local deckPosition = Utils.getSnapPosition(Component.cityMat(), snapPoint)
    return WrappedDeck(--[[---@not nil]] deckPosition)
end

---@return seb_WrappedDeck
function Component.shopDeck()
    return fromCityMat(CityMatSnapPoints.Shop)
end

---@return seb_WrappedDeck
function Component.rewardItemsDeck()
    return fromCityMat(CityMatSnapPoints.RewardItems)
end

---@param index number
---@return seb_WrappedDeck
function Component.itemDeck(index)
    return fromCityMat(index + 1)
end

--------------------------------------------------------------------------------
--- Deck-Mat -------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Object
function Component.deckMat()
    return --[[---@not nil]] getObjectFromGUID(Guid.DeckMat)
end

---@param snapPoint number
---@return seb_WrappedDeck
local function fromDeckMat(snapPoint)
    local deckPosition = Utils.getSnapPosition(Component.deckMat(), snapPoint)
    return WrappedDeck(--[[---@not nil]] deckPosition)
end

---@return seb_WrappedDeck
function Component.questDeck()
    return fromDeckMat(DeckMatSnapPoints.Quests)
end

---@return seb_WrappedDeck
function Component.randomScenarioDeck()
    return fromDeckMat(DeckMatSnapPoints.RandomScenarios)
end

---@param eventDeckInfo gh_EventDeckInfo
---@return tts__Deck
function Component.initialEventDeck(eventDeckInfo)
    local wrappedDeck = fromDeckMat(eventDeckInfo.initialDeckAt)
    return --[[---@type tts__Deck]] wrappedDeck.unwrap()
end

---@param eventDeckInfo gh_EventDeckInfo
---@return seb_WrappedDeck
function Component.eventDeck(eventDeckInfo)
    return fromDeckMat(eventDeckInfo.deckAt)
end

---@return seb_WrappedDeck
function Component.minusOneDeck()
    return fromDeckMat(DeckMatSnapPoints.MinusOneDeck)
end

---@return seb_WrappedDeck
function Component.battleGoalsDeck()
    return fromDeckMat(DeckMatSnapPoints.BattleGoals)
end

--------------------------------------------------------------------------------
--- Event Mat ------------------------------------------------------------------
--------------------------------------------------------------------------------

---@return tts__Object
function Component.eventMat()
    return --[[---@not nil]] getObjectFromGUID(Guid.EventsMat)
end

---@param info gh_EventDeckInfo
---@return seb_WrappedDeck
function Component.eventMatDeck(info)
    ---@type tts__Vector
    local position
    if getObjectFromGUID(Guid.OldEventsMat) then
        if info.oldMat then
            position = --[[---@not nil]] Utils.getSnapPosition(--[[---@not nil]] getObjectFromGUID(--[[---@not nil]] info.oldMat), 1)
        else
            position = --[[---@not nil]] Utils.getSnapPosition(--[[---@not nil]] Component.eventMat(), 1)
        end
    else
        position = --[[---@not nil]] Utils.getSnapPosition(--[[---@not nil]] Component.eventMat(), info.atEventMat)
    end

    return WrappedDeck(position)
end

--------------------------------------------------------------------------------
--- Character specific ---------------------------------------------------------
--------------------------------------------------------------------------------

---@param className string
---@return nil | tts__Bag
function Component.classBox(className)
    return --[[---@type nil | tts__Bag]] getObjectFromGUID(Game.class(className).boxGuid)
end

--- Returns the contained character box within a class box for the given class.
---@param classBox tts__Bag | tts__ContainerState
---@return tts__ContainerState
function Component.characterBox(classBox)
    ---@type tts__ObjectState[]
    local contained = {}
    if Object.isObject(classBox) then
        contained = (--[[---@type tts__Bag]] classBox).getData().ContainedObjects
    else
        contained = (--[[---@type tts__ContainerState]] classBox).ContainedObjects
    end

    if TableUtil.isEmpty(contained) then
        Logger.error("The class box for '%s' seems to be empty. This will result in an error! Did you reset the box and forget to include a new character box?", Object.name(classBox))
    end

    return --[[---@type tts__ContainerState]] contained[1]
end

---@param object seb_Object_Identifiable
---@return boolean
function Component.isPlayerMat(object)
    return Object.name(object):find(Names.PlayerMat) ~= nil
end

---@param object tts__ObjectState
---@return boolean
function Component.isCharacterSheet(object)
    return Object.name(object) == Names.CharacterSheet
end

---@param object seb_Object_Identifiable
function Component.isAbilityDeck(object)
    if not (Object.isSimple(object) or Object.isDeck(--[[---@type seb_Object]] object)) then
        return false
    end
    local name = Object.name(object)
    return name:find(Names.AbilityDeck) ~= nil or name:find(Names.StartingAbilityDeck) ~= nil
end

---@param player number
---@return seb_WrappedDeck
function Component.abilityDeck(player)
    local abilityDeck = --[[---@type tts__Deck]] Search.inZone(Component.playerZone(player), { name = Names.AbilityDeck })
    return WrappedDeck(abilityDeck)
end

---@param player number
---@return tts__Vector
function Component.abilityDeckPosition(player)
    return relativeToZone(player, Positions.AbilityDeck)
end

---@param object seb_Object
---@param className string
---@return nil | string
function Component.getAbilityNameForClass(object, className)
    local name = Object.name(object)

    if not Object.isCard(object)
            or not Object.description(object):find(className)
            or name:find(Names.AttackModifierCard)
    then
        return nil
    end

    local cardName = StringUtil.replace(name, "%s?[%(%)]%d%d[%)%(]")
    local nearest, _ = Game.nearestAbility(className, cardName)
    if nearest then
        return (--[[---@not nil]] nearest).name
    end
end

---@param className string
---@param abilityName string
function Component.isStartingAbility(className, abilityName)
    local ability = --[[---@not nil]] Game.ability(className, abilityName)
    return ability.level == 1 or ability.level == "X"
end

---@return tts__Bag[]
function Component.inactiveCharacters()
    return --[[---@type tts__Bag[] ]] getObjectsWithTag(Component.Tag.InactiveCharacter)
end

---@return tts__Bag[]
function Component.packedCharacters()
    return --[[---@type tts__Bag[] ]] TableUtil.filter(getObjects(), function(obj)
        return Object.isBag(obj) and obj.getDescription() == Names.InactiveCharacter
    end)
end

---@param player number
---@param positionName gh_Save_Character_Item_Position
---@return tts__Vector
function Component.itemPosition(player, positionName)
    if positionName then
        local snapPoint = PlayerMatItemPositions[positionName]
        if snapPoint then
            return --[[---@not nil]] Utils.getSnapPosition(Component.playerMat(player), snapPoint)
        end
    end
    return relativeToZone(player, Positions.ItemUnequipped)
end

---@param playerMat tts__Object
---@param object tts__Object | tts__ObjectState
---@return gh_Save_Character_Item_Position
function Component.itemPositionName(playerMat, object)
    for name, snap in pairs(PlayerMatItemPositions) do
        local snapPosition = Utils.getSnapPosition(playerMat, snap)
        if snapPosition then
            (--[[---@not nil]] snapPosition).y = 0
            local objectPosition = Object.position(object)
            objectPosition.y = 0

            if (--[[---@not nil]] snapPosition):equals(objectPosition) then
                return name
            end
        end
    end

    return "Unequipped"
end

--------------------------------------------------------------------------------
--- Player specific ------------------------------------------------------------
--------------------------------------------------------------------------------

---@return number
function Component.playerCount()
    if is5PlayerVersion() then
        return 5
    end
    return 4
end

---@return GUID[]
function Component.playerZones()
    if is5PlayerVersion() then
        return Guids.Zones5Players
    end
    return Guids.Zones
end

---@param player number
---@return tts__ScriptingTrigger
function Component.playerZone(player)
    return --[[---@type tts__ScriptingTrigger]] getObjectFromGUID(Component.playerZones()[player])
end

--- Returns all objects of the given player. Only objects which center is within the planar bounds of the player zone
--- are returned. This avoids duplicated objects that overlap multiple zones.
---@param player number
---@return tts__Object[]
function Component.playerObjects(player)
    local zone = Component.playerZone(player)
    return TableUtil.filter(zone.getObjects(),
            function(object)
                return Utils.isCenterInZone(zone, object)
            end)
end

---@param player number
---@param object tts__Object
---@return boolean
function Component.isPlayerObject(player, object)
    local zone = Component.playerZone(player)
    return Utils.isCenterInZone(zone, object)
end

---@param player number
---@return tts__Object[]
function Component.playerHand(player)
    return Player[Component.PlayerColors[player]].getHandObjects()
end

---@param playerMat tts__ObjectState
function Component.adjustPlayerMatSnapPoints(playerMat)
    ---@param snaps tts__ObjectState_SnapPoint[]
    ---@param zPosition number
    local function addSnapPoint(snaps, zPosition)
        table.insert(snaps, {
            Position = { x = 1.52, y = 0.1, z = zPosition },
            Tags = {},
        })
    end

    local snaps = --[[---@not nil]] playerMat.AttachedSnapPoints
    addSnapPoint(snaps, -0.72)
    addSnapPoint(snaps, -0.24)
    addSnapPoint(snaps, 0.24)
    addSnapPoint(snaps, 0.72)

    if playerMat.States then
        for _, state in pairs(--[[---@not nil]] playerMat.States) do
            Component.adjustPlayerMatSnapPoints(state)
        end
    end
end

---@param player number
---@param callback fun(): void
function Component.loadPlayer(player, callback)
    local playerZoneGuid = Component.playerZones()[player]
    Component.addPlayerButton(player).call("addPlayer")
    Utils.waitForObjectInZone(playerZoneGuid, { name = Names.PlayerMat }, function()
        callback()
    end)
end

---@param player number
---@param characterBoxData tts__BagState
function Component.placeCharacterBox(player, characterBoxData)
    spawnObjectData({
        data = characterBoxData,
        position = relativeToZone(player, Positions.CharacterBox),
    })
end

---@param player number
---@param character gh_Save_Character
---@param object tts__ObjectState
---@param component gh_PlayerComponent
function Component.placePlayerComponent(player, character, object, component)
    local position
    if component.snapPoint then
        position = Utils.getSnapPosition(Component.playerMat(player), --[[---@not nil]] component.snapPoint)
    else
        position = relativeToZone(player, --[[---@not nil]] component.position)
    end

    spawnObjectData({
        data = object,
        position = position:add({ x = 0, y = 1, z = 0 }),
        rotation = component.rotation,
        callback_function = function(obj)
            if component.locked then
                obj.setLock(true)
            end
            if component.event then
                Wait.time(function()
                    Task.completeForPlayer(--[[---@not nil]] component.event, obj, player, character)
                end, 1)
            end
        end,
    })
end

---@param player number
---@param character gh_Save_Character
---@param contained tts__ObjectState
---@param component gh_Game_Class_Extra
function Component.placeExtraPlayerComponent(player, character, contained, component)
    if component.type == "Figurine" then
        Component.placePlayerComponent(player, character, contained, {
            position = Vector(--[[---@not nil]] Component.PlayerComponent.Figurine.position) + Vector(2, 0, 0),
            event = Task.Event.Character.Figurine,
        })
    elseif component.type == "Card" then
        Component.placePlayerComponent(player, character, contained, {
            position = Positions.Hand,
        })
    else
        ---@type table<string, tts__VectorShape>
        local positionByType = {
            Rules = Positions.ExtraRules,
            Token = Positions.ExtraTokens,
        }
        local position = positionByType[component.type]
        Component.placePlayerComponent(player, character, contained, {
            position = position,
            rotation = { 0, 180, 0 }
        })
    end
end

---@param player number
---@param character gh_Save_Character
---@param component gh_PlayerComponent
function Component.placeAdditionalPlayerComponents(player, character, component)
    ---@type nil | tts__Bag
    local fromBag
    if component.playerBag then
        local bagGuid = (--[[---@not nil]] component.playerBag)[player]
        fromBag = --[[---@type tts__Bag]] getObjectFromGUID(bagGuid)
    elseif component.bag then
        fromBag = --[[---@type tts__Bag]] getObjectFromGUID(--[[---@not nil]] component.bag)
    end

    if fromBag then
        local object = (--[[---@not nil]] fromBag).getData().ContainedObjects[1]
        Component.placePlayerComponent(player, character, object, component)
    end
end

---@param index number
---@return tts__Object
function Component.addPlayerButton(index)
    return --[[---@not nil]] getObjectFromGUID(addPlayerButtonsGuids()[index])
end

---@return tts__Object
function Component.playerMat(player)
    return --[[---@not nil]] Search.inZone(Component.playerZone(player), { name = Names.PlayerMat, isPattern = true })
end

---@param player number
---@return nil | tts__Object
function Component.characterMat(player)
    return Search.inZone(Component.playerZone(player), { name = Names.CharacterMat })
end

---@param player number
---@return tts__Object
function Component.characterSheet(player)
    return --[[---@not nil]] Search.inZone(Component.playerZone(player), { name = Names.CharacterSheet })
end

---@param player number
---@return tts__Deck
function Component.attackModifiers(player)
    local search = { name = Names.AttackModifierDeck, description = "Player", isPattern = true }
    return --[[---@type tts__Deck]] Search.inZone(Component.playerZone(player), search)
end

---@param player number
---@return seb_WrappedDeck
function Component.additionalAttackModifiers(player)
    for _, obj in ipairs(Component.playerZone(player).getObjects()) do
        if obj.type == Object.Type.Deck
                and obj.getName() == Names.AttackModifierDeck
                and obj.getDescription() ~= "Player " .. player then
            return WrappedDeck(--[[---@type tts__Deck]] obj)
        end
    end
end

---@param name string
---@return string
function Component.modifierNamePattern(name)
    return "^" .. Names.AttackModifierCard .. " " .. StringUtil.escapePattern(name) .. "$"
end

---@param player number
---@return nil | string
function Component.playerClass(player)
    local characterMat = Component.characterMat(player)
    if characterMat then
        return (--[[---@not nil]] characterMat).getDescription()
    end
    return nil
end

--------------------------------------------------------------------------------
--- Specific cards -------------------------------------------------------------
--------------------------------------------------------------------------------

--- Returns true if the given object is an item card.
---@param object seb_Object
function Component.isItemCard(object)
    return Object.isCard(object)
            and (Component.isItemCardDescription(Object.description(object))
            or Game.Items.List[Object.name(object)] ~= nil)
end

--- Returns true if the given item card object is an item from the rewards or item design deck.
---@param item seb_Object
---@param prosperityLevel nil | number
function Component.isRewardItemCard(item, prosperityLevel)
    if not Component.isItemCard(item) then
        return false
    end

    prosperityLevel = prosperityLevel or 1
    if Object.description(item) == "" then
        local itemInfo = Game.Items.List[Object.name(item)]
        return itemInfo.reward ~= nil or itemInfo.prosperity > prosperityLevel
    else
        local description = Object.description(item)
        description = StringUtil.replace(description, "red")
        description = StringUtil.replace(description, "blue")
        return tonumber(description) > Game.Items.Prosperity[--[[---@not nil]] prosperityLevel]
    end
end

--- Returns true if the given object description is a possible item card's description.
function Component.isItemCardDescription(description)
    return description:find("^%d+$")
            or description:find("^%d+ red$")
            or description:find("^%d+ blue$")
end

---@param object seb_Object
function Component.isPersonalQuestCard(object)
    local customDeck = (--[[---@type tts__DeckCustomState]] Object.data(object)).CustomDeck
    if not Object.isCard(object) or not customDeck then
        return false
    end

    for key, _ in pairs(customDeck) do
        return TableUtil.contains(DeckIds.Quests, key)
    end
end

---@param object seb_Object
---@return nil | gh_Game_Quest_Info
function Component.getQuestInfo(object)
    local cardId = Object.data(object).CardID
    local cardIndex = tonumber(tostring(cardId):sub(-2, -1))
    for name, quest in pairs(Game.Quests) do
        if quest.index == cardIndex then
            return { name = name, index = quest.index, number = quest.number }
        end
    end

    return nil
end

---@param customDeck number[]
---@param index number
---@return number
local function getCardId(customDeck, index)
    local customDeckId = customDeck[#customDeck]
    return --[[---@not nil]] tonumber(string.format("%d%02d", customDeckId, index))
end

---@param index number
---@return number
function Component.getQuestCardId(index)
    return getCardId(DeckIds.Quests, index)
end

---@param index number
---@return number
function Component.getScenarioCardId(index)
    return getCardId(DeckIds.RandomScenarios, index)
end

---@param object nil | tts__Object
---@param name string
local function verifyObject(object, name)
    assert(object ~= nil, name .. " is missing ")
end

---@param container tts__Container
---@param content GUID
---@param name string
local function verifyContent(container, content, name)
    assert(getObjectFromGUID(content)
            or Search.inContainer(container, { guid = content }),
            name .. " is missing")
end

---@param object tts__Object
---@param tableName string
---@param name string
local function verifyTable(object, tableName, name)
    assert(object.getTable(tableName), name .. " is missing")
end

--- Verifies that the script can actually run, by checking if needed objects exists.
function Component.verifyLoad()
    local gamebox = Component.gamebox()
    verifyObject(gamebox, "Gamebox")
    verifyContent(gamebox, Guid.LockedClasses, "Locked classes")
    verifyContent(gamebox, Guid.ScenarioBook, "Scenario book")
    verifyContent(gamebox, Guid.RuleBook, "Rule book")
    verifyContent(gamebox, Guid.OpeningConditions, "Opening Conditions")
    verifyContent(gamebox, Guid.RetirementSheet, "Retirement Sheet")
    verifyContent(gamebox, Guid.TownRecords, "Town Records")

    local map = Component.map()
    verifyObject(map, "Map")
    verifyTable(map, "tableML", "Scenario information")
    verifyTable(map, "Pros", "Prosperity information")

    verifyObject(Component.achievementsBag(), "Achievements bag")
    verifyObject(Component.deckMat(), "Deck Mat")
    --verifyObject(Component.minusOneDeck(), "-1 Deck")
    verifyObject(Component.cityMat(), "City Mat")
    verifyObject(Component.eventMat(), "Events Mat")
    verifyObject(Component.partySheet(), "Party Sheet")

    for i, zone in ipairs(Component.playerZones()) do
        verifyObject(getObjectFromGUID(zone), "Player zone " .. i)
    end
    for i, button in pairs(addPlayerButtonsGuids()) do
        verifyObject(getObjectFromGUID(button), "Add Player button " .. i)
    end
end

--------------------------------------------------------------------------------
--- Discard --------------------------------------------------------------------
--------------------------------------------------------------------------------

---@overload fun(card: tts__Card, name: string, position: tts__NumVectorShape): void
---@param card tts__Card
---@param name string
---@param discardPosition tts__NumVectorShape
---@param player number
local function discardCard(card, name, discardPosition, player)
    if Options.keepDiscardedItems then
        local position = Vector(discardPosition)
        if player then
            position = relativeToZone(player, Positions.AttackModifierDiscard)
        end

        local discarded = WrappedDeck(position)
        discarded.setName(name)
        discarded.putObject(card)
    else
        card.destruct()
    end
end

---@param card tts__Card
---@param player number
function Component.discardAttackModifier(card, player)
    discardCard(card, "Discarded Attack Modifiers", Positions.AttackModifierDiscard, player)
end

---@param card tts__Card
function Component.discardScenario(card)
    discardCard(card, "Discovered Scenarios", Positions.ScenarioDiscard)
end

---@param card tts__Card
function Component.discardTreasure(card)
    discardCard(card, "Looted Treasures", Positions.LootedTreasures)
end

---@param card tts__Card
function Component.discardQuest(card)
    discardCard(card, "Completed Quests", Positions.CompletedQuests)
end

---@param card tts__Card
---@param eventInfo gh_EventDeckInfo
function Component.discardEvent(card, eventInfo)
    discardCard(card, "Discarded " .. eventInfo.name, eventInfo.discardPosition)
end

---@return string
function Component.scriptOnManager()
    return [[
---@return nil | tts__Object
function findManager()
    local withTag = getObjectsWithTag("]] .. Component.Tag.CampaignManager .. [[")
    if withTag == nil then
        return nil
    end

    return withTag[1]
end

---@param functionName string
---@param parameters table
---@return boolean
function performOnManager(functionName, parameters)
    local manager = findManager()
    if not manager then
        printToAll("Can not find the Gloomhaven Campaign Manager!]]
            .. " In order to execute this function its presence is required."
            .. " Add it somewhere on the table and try again." .. [[", { r=1, g=0, b=0 })
        return false
    else
        manager.call(functionName, parameters)
        return true
    end
end
]]
end

---@param parameters tts__CreateButtonParameters
---@return string
function Component.scriptButton(parameters)
    ---@param tab nil | table
    ---@return string
    local function tableString(tab)
        if not tab then
            return "nil"
        else
            return TableUtil.dump(--[[---@not nil]] tab)
        end
    end

    return [[
function onLoad()
    self.createButton({
        label = "]] .. (parameters.label or "") .. [[",
        tooltip = "]] .. (parameters.tooltip or "") .. [[",
        function_owner = self,
        click_function = "]] .. parameters.click_function .. [[",
        position = ]] .. tableString(parameters.position) .. [[,
        rotation = ]] .. tableString(parameters.rotation) .. [[,
        scale = ]] .. tableString(parameters.scale) .. [[,
        width = ]] .. tostring(parameters.width) .. [[,
        height = ]] .. tostring(parameters.height) .. [[,
        font_size = ]] .. tostring(parameters.font_size) .. [[,
        color = ]] .. tableString(parameters.color) .. [[,
        font_color = ]] .. tableString(parameters.font_color) .. [[,
    })
end
]]
end

return Component
