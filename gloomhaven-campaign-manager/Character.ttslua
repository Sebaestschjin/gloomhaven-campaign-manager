local Base64 = require("ge_tts.Base64")

local Chain = require("sebaestschjin-tts.Chain")
local Constant = require("sebaestschjin-tts.Constant")
local Logger = require("sebaestschjin-tts.Logger")
local Object = require("sebaestschjin-tts.Object")
local Search = require("sebaestschjin-tts.Search")
local StringUtil = require("sebaestschjin-tts.StringUtil")
local TableUtil = require("sebaestschjin-tts.TableUtil")
local Utils = require("sebaestschjin-tts.Utils")

local Component = require("gloomhaven-campaign-manager.Component")
local Game = require("gloomhaven-campaign-manager.Game")
local Quest = require("gloomhaven-campaign-manager.Quest")
local Shop = require("gloomhaven-campaign-manager.Shop")

local Character = {}

local AbilityDefaultDistance = 5
local AbilityMaxDistance = AbilityDefaultDistance + 2

---@param index number
---@param character gh_Save_Character
function Character.load(index, character)
    Logger.info("Loading Character %s at %d", character.class, index)

    local playerZone = Component.playerZones()[index]
    Component.playerButton(index).call("addPlayer")

    Utils.waitForObjectInZone(playerZone, { name = Component.names.PLAYER_MAT },
            function() Character.unpackCharacterBox(playerZone, character) end)
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.unpackCharacterBox(playerZone, character)
    local playerMat = Component.playerMat(playerZone)
    local classBox = --[[---@not nil]] Component.classBox(character.class)

    classBox.takeObject({
        position = playerMat.getPosition(),
        smooth = false,
    })

    Utils.waitForObjectInZone(playerZone, { name = Component.names.CHARACTER_SHEET },
            function() Character.doLoad(playerZone, character) end)
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.doLoad(playerZone, character)
    -- still need more waiting to init the UI of the sheet :-(
    Wait.time(function() Character.loadCharacterSheet(playerZone, character) end, 1)
    Wait.time(function() Character.loadMaxHp(playerZone, character) end, 5)
    Character.loadAbilities(playerZone, character)
    Character.loadQuest(playerZone, character)
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.loadCharacterSheet(playerZone, character)
    local characterSheet = Component.characterSheet(playerZone)

    if character.name then
        characterSheet.UI.setAttribute("Name", "text", character.name)
    end
    if character.gold then
        characterSheet.call("addEx", { name = "gold", amount = character.gold })
    end
    if character.xp then
        characterSheet.call("addEx", { name = "xp", amount = character.xp })
    end
    if character.checkmarks then
        for i = 1, character.checkmarks do
            characterSheet.call("clickedToggle", "notes" .. tostring(i))
        end
    end
    if character.perks then
        Character.loadPerks(playerZone, character)
    end
    if character.items then
        Character.loadItems(playerZone, character)
    end
    if character.notes then
        characterSheet.UI.setAttribute("NotesFront", "text", table.concat(character.notes, "\n"))
    end
    Character.loadHiddenNotes(characterSheet, character.hiddenNotes)
end

---@param characterSheet tts__Object
---@param hiddenNotes string[]
function Character.loadHiddenNotes(characterSheet, hiddenNotes)
    if not hiddenNotes then
        return
    end

    local decodedNotes = --[[---@type string[] ]]{}
    for i, note in ipairs(hiddenNotes) do
        if StringUtil.isBase64(note) then
            decodedNotes[i] = StringUtil.chars(Base64.decode(note))
        else
            decodedNotes[i] = note
        end
    end
    characterSheet.UI.setAttribute("Notes", "text", table.concat(decodedNotes, "\n"))
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.loadMaxHp(playerZone, character)
    local characterInfo = Game.class(character.class)
    local level = Character.getLevel(character.xp)
    local maxHealth = characterInfo.hp[level]
    local startingHealth = characterInfo.hp[1]

    Character.loadFigureHealth(playerZone, character.class, maxHealth)
    if maxHealth > startingHealth then
        local tokenName = startingHealth .. " hp"
        local healthToken = --[[---@not nil]] Search.inZone(Component.playerZone(playerZone), { name = tokenName })
        healthToken.setState(maxHealth)
    end

    if characterInfo.extraFigure then
        maxHealth = (--[[---@not nil]] characterInfo.extraFigure).hp[level]
        Character.loadFigureHealth(playerZone, (--[[---@not nil]] characterInfo.extraFigure).name, maxHealth)
    end
end

---@param playerZone GUID
---@param name string
---@param health number
function Character.loadFigureHealth(playerZone, name, health)
    local figure = --[[---@not nil]] Search.inZone(Component.playerZone(playerZone), { name = name, type = Object.Type.Figurine })

    figure.setTable("health", { value = health, max = health })
    figure.call("setHealth")
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.loadAbilities(playerZone, character)
    if not character.abilities then return end

    local abilityDeck = --[[---@not nil]] Component.abilityDeck(playerZone)
    for _, abilityName in pairs(character.abilities) do
        local abilityCard, distance = Search.nearestInWrappedDeck(abilityDeck, abilityName, AbilityMaxDistance)
        if abilityCard then
            if distance ~= AbilityDefaultDistance then
                Logger.warn("Tried to load the ability '%s' for class '%s', but couldn't find it in the ability deck."
                        .. " However, found a similar ability named '%s' which will be used instead."
                        .. " Please verify if this assumption is correct.",
                        abilityName, character.class, Object.name(--[[---@not nil]] abilityCard))
            end
            abilityDeck.takeObject({
                position = Component.secondHandPosition(playerZone),
                guid = Object.guid(--[[---@not nil]] abilityCard),
            })
        else
            Logger.error("An ability named '%s' does not exist for the character class '%s'!",
                    abilityName, character.class)
        end
    end
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.loadQuest(playerZone, character)
    if not character.quest then return end

    local callback = function(card)
        card.setPosition(Component.questPosition(playerZone))
    end
    if not Quest.take(character.quest, callback) then
        Logger.error("A quest named '%s' does not exist. Can't draw the quest from the deck.", character.quest)
    end
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.loadPerks(playerZone, character)
    local perkInfo = Game.class(character.class).perks
    local characterSheet = --[[---@not nil]] Component.characterSheet(playerZone)
    local currentDeck = Component.attackModifiers(playerZone)
    local additionalDeck = Component.additionalAttackModifiers(playerZone)

    local chain = Chain.create()
    for _, perk in ipairs(character.perks) do
        if perkInfo[perk] then
            characterSheet.call("clickedToggle", "perk" .. tostring(perk))

            for _, card in TableUtil.ipairs(perkInfo[perk].add) do
                chain.add(function(c)
                    Character.addModifierCard(c, character, additionalDeck, currentDeck, card)
                end)
            end
            for _, card in TableUtil.ipairs(perkInfo[perk].remove) do
                chain.add(function(c)
                    Character.removeModifierCard(c, character, currentDeck, card)
                end)
            end
        else
            Logger.error("A perk '%s' does not exist for class '%s'.", perk, character.class)
        end
    end
    chain.add(function()
        currentDeck.shuffle()
        return true
    end)

    chain.proceed()
end

---@param chain common_Chain
---@param character gh_Save_Character
---@param additionalDeck seb_WrappedDeck
---@param currentDeck tts__Deck
---@param card string
---@return boolean
function Character.addModifierCard(chain, character, additionalDeck, currentDeck, card)
    Logger.verbose("%s: Adding %s", character.class, card)

    local search = { name = Character.modifierNamePattern(card), isPattern = true }
    local foundCard, _ = Search.inContainedObjects(additionalDeck, search)
    if not foundCard then
        Logger.error("%, adding: Can't find modifier card %s.", character.class, card)
        return true
    end

    additionalDeck.takeObject({
        guid = Object.guid(--[[---@not nil]] foundCard),
        position = Component.getSafePosition(),
        smooth = false,
        callback_function = function(c)
            currentDeck.putObject(c)
            chain.proceed()
        end
    })

    return false
end

---@param chain common_Chain
---@param character gh_Save_Character
---@param currentDeck tts__Deck
---@param card string
---@return boolean
function Character.removeModifierCard(chain, character, currentDeck, card)
    Logger.verbose("%s: Removing %s", character.class, card)

    local search = { name = Character.modifierNamePattern(card), isPattern = true }
    local foundCard = Search.inContainer(currentDeck, search)
    if not foundCard then
        Logger.error("%s, removing: Can't find modifier card %s.", character.class, card)
        return true
    end

    currentDeck.takeObject({
        guid = (--[[---@not nil]] foundCard).guid,
        position = Component.getSafePosition(),
        smooth = false,
        callback_function = function(c)
            c.destruct()
            chain.proceed()
        end })

    return false
end

---@param name string
---@return string
function Character.modifierNamePattern(name)
    return "^" .. Component.names.ATTACK_MODIFIER .. " " .. StringUtil.escapePattern(name) .. "$"
end

---@param playerZone GUID
---@param character gh_Save_Character
function Character.loadItems(playerZone, character)
    local items = --[[---@type string[] ]] {}

    for _, item in ipairs(character.items) do
        local itemPosition = Character.calculateItemPosition(playerZone, item)

        if Shop.takeItem(item.name, itemPosition, Constant.Rotation.NORTH) then
            table.insert(items, item.name)
            Character.checkForNegativeItemEffects(character, item, itemPosition)
        else
            Logger.error("The item '%s' does not exist. Won't load item.", item.name)
        end
    end

    local characterSheet = Component.characterSheet(playerZone)
    characterSheet.UI.setAttribute("Items", "text", table.concat(items, "\n"))
end

---@param playerZone GUID
---@param item gh_Save_Character_Item
function Character.calculateItemPosition(playerZone, item)
    if item.position then
        local snapPoint = Component.PlayerMatSnapPoints[item.position]
        if snapPoint then
            return Utils.getSnapPosition(Component.playerMat(playerZone), snapPoint)
        end
    end
    return Component.positions.relativeToZone(playerZone, Component.positions.ITEM_UNEQUIPPED)
end

---@param character gh_Save_Character
---@param item gh_Save_Character_Item
---@param itemPosition tts__Vector
function Character.checkForNegativeItemEffects(character, item, itemPosition)
    if not Character.hasNegateItemEffectsPerk(character) then
        local negativeEffect = Game.ITEMS.NegativeEffects[item.name]
        for _ = 1, negativeEffect or 0 do
            Character.dealNegativeItemEffectCard(itemPosition)
        end
    end
end

---@param character gh_Save_Character
---@return boolean
function Character.hasNegateItemEffectsPerk(character)
    local perkInfo = Game.class(character.class).perks
    for _, perk in ipairs(character.perks) do
        if perkInfo[perk].ignore == "I" then
            -- TODO use constant
            return true
        end
    end
    return false
end

---@param itemPosition tts__Vector
function Character.dealNegativeItemEffectCard(itemPosition)
    Component.minusOneDeck().takeObject({
        smooth = false,
        -- position set to ensure PLayer -1 cards placed on top of item
        position = itemPosition + Vector(0, 1, 0)
    })
end

---@param curXP number
---@return number
function Character.getLevel(curXP)
    if not curXP then curXP = 0 end
    for i, xp in pairs(Game.XP_REQUIREMENTS) do
        if curXP < xp then
            return i - 1
        end
    end
    return 9
end

---@param playerZone GUID
---@param characters gh_Save_Character[]
function Character.save(playerZone, characters)
    local character = --[[---@type gh_Save_Character]] {}

    local characterMat = Component.characterMat(playerZone)
    if characterMat then
        character.class = (--[[---@not nil]] characterMat).getDescription()
        local characterSheet = Component.characterSheet(playerZone)
        local characterSheetButtons = characterSheet.getTable("buttons")
        local characterSheetInputs = characterSheet.getTable("inputs")

        if characterSheetInputs then
            -- this is an older version of the sheet, without the inputs where you can directly set the values
            character.name = characterSheetInputs.Name
            character.xp = --[[---@not nil]] tonumber(characterSheetButtons.xp.label)
            character.gold = --[[---@not nil]] tonumber(characterSheetButtons.gold.label)
        else
            character.name = characterSheet.UI.getAttribute("Name", "text")
            character.xp = --[[---@not nil]] tonumber(characterSheet.UI.getAttribute("xp", "text"))
            character.gold = --[[---@not nil]] tonumber(characterSheet.UI.getAttribute("gold", "text"))
            character.notes = StringUtil.split(characterSheet.UI.getAttribute("NotesFront", "text"), { "\n" })
            character.hiddenNotes = Character.saveHiddenNotes(characterSheet)
        end

        local totalCheckmarks = 0
        for i = 1, 18 do
            if characterSheetButtons["notes" .. i].label ~= "" then
                totalCheckmarks = totalCheckmarks + 1
            end
        end
        character.checkmarks = totalCheckmarks

        character.perks = {}
        for i = 1, 15 do
            if characterSheetButtons["perk" .. i].label ~= "" then
                table.insert(character.perks, i)
            end
        end

        character.items = Character.saveItems(playerZone, character.class)
        character.abilities = Character.saveAbilities(playerZone)
        character.quest = Character.saveQuest(playerZone)
    end

    table.insert(characters, character)
end

---@param characterSheet tts__Object
---@return string[]
function Character.saveHiddenNotes(characterSheet)
    local notes = StringUtil.split(characterSheet.UI.getAttribute("Notes", "text"), { "\n" })
    for i, note in ipairs(notes) do
        notes[i] = Base64.encode(StringUtil.bytes(note))
    end

    return notes
end

---@param playerZone GUID
---@param className string
---@return gh_Save_Character_Item[]
function Character.saveItems(playerZone, className)
    local playerMat = Component.playerMat(playerZone)
    local items = --[[---@type gh_Save_Character_Item[] ]] {}
    local zoneObjects = Component.getObjectsInZone(playerZone)
    Character.saveItemFromObjects(zoneObjects, playerMat, items)

    return TableUtil.sortByAttribute(items, "name")
end

---@param objects tts__Object[] | tts__ObjectState[]
---@param playerMat tts__Object
---@param items gh_Save_Character_Item[]
function Character.saveItemFromObjects(objects, playerMat, items)
    for _, object in ipairs(--[[---@type (tts__Object | tts__ObjectState)[] ]] objects) do
        if Component.isItemCard(object) then
            local item = { name = Object.name(object), position = Character.getItemPosition(playerMat, object) }
            table.insert(items, item)
        elseif Object.isContainer(object) then
            Character.saveItemFromObjects(Object.objects(--[[---@type tts__ContainerState]] object), playerMat, items)
        end
    end
end

---@param playerMat tts__Object
---@param object tts__Object | tts__ObjectState
---@return gh_Save_Character_Item_Position
function Character.getItemPosition(playerMat, object)
    for name, snap in pairs(Component.PlayerMatSnapPoints) do
        if Utils.getSnapPosition(playerMat, snap) == Object.position(object) then
            return name
        end
    end

    return "Unequipped"
end

---@param playerZone GUID
---@return string[]
function Character.saveAbilities(playerZone)
    local class = --[[---@not nil]] Character.findClassInZone(playerZone)
    local abilities = --[[---@type string[] ]] {}
    local zoneObjects = Component.getObjectsInZone(playerZone)
    Character.saveAbilitiesFromObjects(zoneObjects, class, abilities)

    table.sort(abilities)
    return abilities
end

---@param objects tts__Object[] | tts__ObjectState[]
---@param class string
---@param abilities string[]
function Character.saveAbilitiesFromObjects(objects, class, abilities)
    for _, object in ipairs(--[[---@type (tts__Object | tts__ObjectState)[] ]] objects) do
        if Component.isAbilityCardForClass(object, class) then
            local name = Component.getAbilityName(class, object)
            if not Component.isStartingAbility(class, name) then
                table.insert(abilities, name)
            end
        elseif Object.isContainer(object) and not Component.isAbilityDeck(object) then
            Character.saveAbilitiesFromObjects(Object.objects(--[[---@type tts__ContainerState]] object), class, abilities)
        end
    end
end

---@param playerZone GUID
---@return number
function Character.saveQuest(playerZone)
    local info = Character.findQuest(playerZone)
    if info then
        return (--[[---@not nil]] info).number
    end
end

---@param className string
---@return nil | GUID
function Character.findZoneForClass(className)
    for _, playerZone in pairs(Component.playerZones()) do
        local characterMat = Component.characterMat(playerZone)
        if characterMat and (--[[---@not nil]] characterMat).getDescription() == className then
            return playerZone
        end
    end
    return nil
end

---@param playerZone GUID
---@return nil | string
function Character.findClassInZone(playerZone)
    local characterMat = Component.characterMat(playerZone)
    if characterMat then
        return (--[[---@not nil]] characterMat).getDescription()
    end
    return nil
end

---@param playerZone GUID
---@return nil | gh_Game_Quest_Info
function Character.findQuest(playerZone)
    for _, object in pairs(Component.getObjectsInZone(playerZone)) do
        if Component.isPersonalQuestCard(object) then
            return Component.getQuestInfo(object)
        end
    end
    return nil
end

return Character
