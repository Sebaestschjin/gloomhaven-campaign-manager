local Constant = require("common/Constant")
local Object = require("common/Object")
local TableUtil = require("common/TableUtil")
local Utils = require("common/Utils")

---@shape common_DeckZone_Partial
---@field tag "Deck"
---@field takeObject fun(parameters:tts__Object_GuidTakeObjectParameters|tts__Object_IndexTakeObjectParameters): tts__Object|nil
---@field putObject fun(object:tts__Object):tts__Deck
---@field getRotation fun():tts__Vector
---@field getPosition fun():tts__Vector

---@shape common_DeckZone: common_DeckZone_Partial
---@field object tts__Card|tts__Deck|nil
---@field isDeck boolean
---@field isEmpty boolean
---@field getObjects fun():tts__IndexedSimpleObjectState[]
---@field getData fun(): tts__ObjectState|common_DeckZone_EmptyState
---@field lastPosition tts__Vector|nil
---@field lastRotation tts__Vector|nil

---@shape common_DeckZone_EmptyState
---@field ContainedObjects table

local DeckUtil = {}

---@param object tts__Deck|tts__Card
---@return common_DeckZone
function DeckUtil.wrap(object)
  local wrapped = DeckUtil.createWrapped()
  if Object.isDeck(object) then
    if object.remainder then
      DeckUtil.makeWrappedCard(wrapped, object.remainder)
    else
      DeckUtil.makeWrappedDeck(wrapped, object)
    end
  elseif Object.isCard(object) then
    DeckUtil.makeWrappedCard(wrapped, object)
  end

  return --[[---@type common_DeckZone]] wrapped
end

---@return common_DeckZone
function DeckUtil.wrapAt(position)
  local hit = Physics.cast({
    origin = position + vector(0, 3, 0),
    direction = Constant.Direction.DOWN,
    type = Constant.Cast.RAY,
  })

  for _, hitInfo in TableUtil.pairs(hit) do
    local object = hitInfo.hit_object
    if object.tag == "Deck" or object.tag == "Card" then
      return DeckUtil.wrap(object)
    end
  end

  local wrapped = DeckUtil.createWrapped()
  DeckUtil.makeWrappedEmpty(wrapped, position)
  return wrapped
end

---@return common_DeckZone_Partial
function DeckUtil.createWrapped()
  local wrapped = --[[---@type common_DeckZone_Partial]] {}

  wrapped.takeObject = function(parameters) return DeckUtil.takeObject(wrapped, parameters) end
  wrapped.putObject = function(object) return DeckUtil.putObject(wrapped, object) end
  wrapped.getPosition = function() return DeckUtil.getPosition(wrapped) end
  wrapped.getRotation = function() return DeckUtil.getRotation(wrapped) end
  wrapped.tag = Object.Tag.Deck

  return wrapped
end

---@param wrapped common_DeckZone_Partial|common_DeckZone
---@param position tts__Vector|nil
---@param rotation tts__Vector|nil
function DeckUtil.makeWrappedEmpty(wrapped, position, rotation)
  ---@alias SimpleObjectStateArray tts__IndexedSimpleObjectState[]
  wrapped.object = nil
  wrapped.isDeck = false
  wrapped.isEmpty = true
  wrapped.getObjects = function() --[[---@type SimpleObjectStateArray]] return {} end
  wrapped.getData = function() return {ContainedObjects={}} end
  wrapped.lastPosition = position
  wrapped.lastRotation = Utils.nvl(rotation, Constant.Rotation.NORTH)
end

function DeckUtil.makeWrappedDeck(wrapped, deck)
  wrapped.object = deck
  wrapped.isDeck = true
  wrapped.isEmpty = false
  wrapped.getObjects = function() return deck.getObjects() end
  wrapped.getData = function() return deck.getData() end
end

function DeckUtil.makeWrappedCard(wrapped, card)
  local cardData = card.getData()
  cardData.ContainedObjects = { cardData }

  wrapped.object = card
  wrapped.isDeck = false
  wrapped.isEmpty = false
  wrapped.getObjects = function() return {
                                    name = card.getName(),
                                    nickname = card.nickname,
                                    description = card.getDescription(),
                                    gm_notes = card.gm_notes,
                                    guid = card.getGUID(),
                                    lua_script = card.lua_script,
                                    lua_script_state = card.lua_script_state,
                                    index = 1,
                       } end
  wrapped.getData = function() return cardData end
end


function DeckUtil.takeObject(wrapped, parameters)
  if wrapped.isDeck then
    local result = wrapped.object.takeObject(parameters)
    if wrapped.object.remainder then
      DeckUtil.makeWrappedCard(wrapped, wrapped.object.remainder)
    end
    return result
  elseif not wrapped.isEmpty then
    DeckUtil.takeObjectForSingleObject(wrapped.object, parameters)
    DeckUtil.makeWrappedEmpty(wrapped, wrapped.object.getPosition(), wrapped.object.getRotation())
  end
end

function DeckUtil.putObject(wrapped, object)
  if wrapped.isEmpty then
    object.setPosition(wrapped.lastPosition)
    object.setRotation(wrapped.lastRotation)
    DeckUtil.makeWrappedCard(wrapped, object)
    return wrapped.object
  elseif wrapped.isDeck then
    return wrapped.object.putObject(object)
  else
    local formedDeck = wrapped.object.putObject(object)
    DeckUtil.makeWrappedDeck(wrapped, formedDeck)
    return formedDeck
  end
end

function DeckUtil.getPosition(wrapped)
  if wrapped.object then
    return wrapped.object.getPosition()
  end

  return wrapped.lastPosition
end

function DeckUtil.getRotation(wrapped)
  if wrapped.object then
    return wrapped.object.getRotation()
  end

  return wrapped.lastRotation
end


function DeckUtil.takeObjectForSingleObject(object, parameters)
  if parameters.guid and object.getGUID() ~= parameters.guid then
    error("Deck doesn't contain guid " .. parameters.guid)
  end

  if parameters.position then
    if parameters.smooth then
      object.setPositionSmooth(parameters.position)
    else
      object.setPosition(parameters.position)
    end
  end

  if parameters.rotation then
    object.setRotation(parameters.rotation)
  elseif parameters.flip then
    object.setRotation(object.getRotation() * vector(1, -1, 1))
  end

  if parameters.callback_function then
    parameters.callback_function(object)
  end
end

return DeckUtil
