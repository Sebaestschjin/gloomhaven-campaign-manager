local Object = require("common/Object")
local ObjectUtil = require("common/ObjectUtil")
local StringUtil = require("common/StringUtil")
local TableUtil = require("common/TableUtil")

local Utils = {}

--- Reads the body of the notebook with the given name.
---@param name string
---@return nil | string
function Utils.readNotebook(name)
  for _, notebook in pairs(Notes.getNotebookTabs()) do
    if notebook.title == name then
      return notebook.body
    end
  end
  return nil
end

---@overload fun(guid, callback: (fun(): void), timeout: number): void
---@overload fun(guid, callback: (fun(): void)): void
---@param guid GUID
---@param callback fun(): void
---@param timeout number
---@param timeoutCallback fun(): void
function Utils.waitForObject(guid, callback, timeout, timeoutCallback)
  local waiter = function() return getObjectFromGUID(guid) ~= nil end
  Wait.condition(callback, waiter, timeout, timeoutCallback)
end


function Utils.waitForObjectInZone(zone, search, callback, timeout, timeout_callback)
  local waiter = function() return Utils.findObjectIn(zone, search) ~= nil end
  Wait.condition(callback, waiter, timeout, timeout_callback)
end

---@param container GUID | tts__Container
function Utils.findObjectIn(container, search)
  local objects = Utils.getObjects(container)

  for _, object in TableUtil.pairs(objects) do
    if Utils.matchesSearch(object, search) then
      return object
    end
  end
end

function Utils.findNearestObjectIn(container, name, maxDistance)
  local objects = Utils.getObjects(container)
  local nearestDistance, nearestObject = nil

  for _, object in TableUtil.pairs(objects) do
    local distance = StringUtil.distance(object.getName(), name)
    if (not maxDistance or distance <= maxDistance)
        and (not nearestDistance or distance < nearestDistance) then
      nearestDistance = distance
      nearestObject = object
    end
  end

  return nearestObject, nearestDistance
end

---@param container GUID | tts__Container | tts__Object[]
---@return tts__Object[]
function Utils.getObjects(container)
  if StringUtil.isGuid(container) then
    container = getObjectFromGUID(container)
  end

  if Object.isContainer(container) then
    return ObjectUtil.getContainedObjects(container)
  elseif container.getObjects then
    return container.getObjects()
  end

  return container
end

function Utils.matchesSearch(object, search)
  return Utils.findNonEmpty(object.getName(), search.name, search.plain)
         and Utils.findNonEmpty(object.getDescription(), search.description, search.plain)
         and Utils.findNonEmpty(object.getGUID(), search.guid, search.plain)
         and Utils.findNonEmpty(object.tag, search.tag, search.plain)
         and Utils.findNonEmpty(tostring(object.getData().CardID), search.cardId, search.plain)
end


---@deprecated Use findObjectIn (doesn't support functions yet, though)
function Utils.findObjectInZone(zone_guid, search)
  local zone = getObjectFromGUID(zone_guid)
  local plain = search.plain
  if not plain then plain = false end

  local tester
  if search.func then
    tester = search.func
  else
    tester = function(object)
               return Utils.findNonEmpty(object.getGUID(), search.guid, plain)
                      and Utils.findNonEmpty(object.getName(), search.name, plain)
                      and Utils.findNonEmpty(object.getDescription(), search.description, plain)
                      and Utils.findNonEmpty(object.tag, search.tag, plain)
               end
  end

  for _, object in pairs(zone.getObjects()) do
    if tester(object) then
      return object
    end
  end
  return nil
end


function Utils.findNonEmpty(value, pattern, plain)
  return pattern == nil or value:find(pattern, nil, plain)
end

---@param object tts__Object
---@param snapPoint number
---@return tts__Vector
function Utils.getSnapPosition(object, snapPoint)
  return object.positionToWorld(object.getSnapPoints()[snapPoint].position)
end

return Utils
