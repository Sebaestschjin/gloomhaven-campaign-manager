local DeckUtil = require("common/deckUtil")

Character = {}


function Character.load(index, character)
  local taskName = "Character " .. tostring(character.class) .. " at " .. index
  Task.load(taskName, character, Character.validate, function(input)
                                                       Character.startLoading(index, input)
                                                     end)
end


function Character.validate(character)
  if not Game.CLASSES[character.class] then
    Error.add("A class named '%s' does not exist.", character.class)
    return false, Error.pop()
  end

  if not Game.QUESTS[character.quest] then
    Error.add("A quest named '%s' does not exist. Can't draw the quest from the deck.", character.quest)
    character.quest = nil
  end

  for i, ability in TableUtil.pairs(character.abilities) do
    if not Game.CLASSES[character.class].abilities[ability] then
      Error.add("An ability named '%s' does not exist for the character class '%s'", ability, character.class)
      character.abilities[i] = nil
    end
  end

  for i, item in TableUtil.pairs(character.items) do
    if not Shop.findItem(item.name) then
      -- TODO this has a timing issue with building the shop
      -- Error.add("The item '%s' does not exist. Won't load item.", item.name)
      -- character.items[i] = nil
    elseif item.position and item.position ~= "Unequipped" and not snaps[item.position] then
      Error.add("An position named '%s' does not exist for item '%s'. Will default to 'Unequipped'.",
                 item.position, item.name)
      item.position = nil
    end
  end

  for i, perk in TableUtil.pairs(character.perks) do
    if not Game.CLASSES[character.class].perks[perk] then
      Error.add("A perk '%s' does not exist for class '%s'.", perk, character.class)
      character.perks[i] = nil
    end
  end

  return true, Error.pop()
end

function Character.startLoading(index, character)
  local playerZone = guids.ZONES[index]
  getObjectFromGUID(guids.ADD_PLAYERS[index]).call("addPlayer")

  Utils.waitForObjectInZone(playerZone, {name=names.PLAYER_MAT},
                            function() Character.unpackCharacterBox(playerZone, character) end)
end

function Character.unpackCharacterBox(playerZone, character)
  local playerMat = Component.playerMat(playerZone)
  local characterBox = getObjectFromGUID(Game.CLASSES[character.class].boxGuid)

  characterBox.takeObject({
    position = playerMat.getPosition(),
    smooth = false,
  })

  Utils.waitForObjectInZone(playerZone, {name=names.CHARACTER_SHEET},
                            function() Character.doLoad(playerZone, character) end)
end


function Character.doLoad(playerZone, character)
  -- still need more waiting to init the UI of the sheet :-(
  Wait.time(function() Character.loadCharacterSheet(playerZone, character) end, 1)
  Wait.time(function() Character.loadMaxHp(playerZone, character) end, 5)
  Character.loadAbilities(playerZone, character)
  Character.loadQuest(playerZone, character)
end


function Character.loadCharacterSheet(playerZone, character)
  local characterSheet = Component.characterSheet(playerZone)

  if character.name then
    characterSheet.UI.setAttribute("Name", "text", character.name)
  end
  if character.gold then
    characterSheet.call('addEx', {name='gold', amount=character.gold})
  end
  if character.xp then
    characterSheet.call('addEx', {name='xp', amount=character.xp})
  end
  if character.checkmarks then
    for i=1, character.checkmarks do
      characterSheet.call('clickedToggle', "notes"..tostring(i))
    end
  end
  if character.perks then
    Character.loadPerks(playerZone, character)
  end
  if character.items then
    Character.loadItems(playerZone, character)
  end
  if character.notes then
    characterSheet.UI.setAttribute("NotesFront", "text", table.concat(character.notes, "\n"))
  end
  if character.hiddenNotes then
    characterSheet.UI.setAttribute("Notes", "text", table.concat(character.hiddenNotes, "\n"))
  end
end


function Character.loadMaxHp(playerZone, character)
  local characterInfo = Game.CLASSES[character.class]
  local level = Character.getLevel(character.xp)
  local maxHealth = characterInfo.hp[level]
  local startingHealth = characterInfo.hp[1]

  Character.loadFigureHealth(playerZone, character.class, maxHealth)
  if maxHealth > startingHealth then
    local tokenName = startingHealth .. " hp"
    local healthToken = Utils.findObjectInZone(playerZone, {name=tokenName})
    healthToken.setState(maxHealth)
  end

  if characterInfo.extraFigure then
    maxHealth = characterInfo.extraFigure.hp[level]
    Character.loadFigureHealth(playerZone, characterInfo.extraFigure.name, maxHealth)
  end
end


function Character.loadFigureHealth(playerZone, name, health)
  local figure = Utils.findObjectInZone(playerZone, {name=name, tag=Tag.FIGURINE})

  figure.getVar('health')["max"] = health
  figure.getVar('health')["value"] = health
  figure.call('setHealth')
end

function Character.loadAbilities(playerZone, character)
  if not character.abilities then return end

  local abilityDeck = Component.abilityDeck(playerZone)
  local secondHandPos = {abilityDeck.getPosition().x,3,-59}
  for _, ability in pairs(character.abilities) do
    local abilityCard = Utils.findObjectInfoInStack(abilityDeck, {name=ability})
    abilityDeck.takeObject({
      position = secondHandPos,
      guid = abilityCard.guid
    })
  end
end


function Character.loadQuest(playerZone, character)
  if not character.quest then return end

  local callback = function(card) card.setPosition(positions.relativeToZone(playerZone, positions.QUEST_CARD)) end
  Quest.take(character.quest, callback)
end


function Character.loadPerks(playerZone, character)
  local perkInfo = Game.CLASSES[character.class].perks
  local characterSheet = Component.characterSheet(playerZone)
  local modifierDeck = Utils.findObjectInZone(playerZone, {name=names.MODIFIER_DECK, description="Player"})
  local isOtherDeck = function(obj) return obj.getName():find(names.MODIFIER_DECK)
                                           and obj.getGUID() ~= modifierDeck.getGUID()
                                    end
  local additionalModifierDeck = Utils.findObjectInZone(playerZone, {func=isOtherDeck})

  for _, perk in TableUtil.pairs(character.perks) do
    characterSheet.call('clickedToggle', "perk"..tostring(perk))
    Character.adjustAttackModifierDeck(modifierDeck, additionalModifierDeck, perkInfo[perk])
    if additionalModifierDeck.remainder then
      -- Remainder may only live for a single frame after last card is taken
      -- May need to move this into the adjustAttackModifierDeck routine itself to reduce
      -- any delay.
      additionalModifierDeck = additionalModifierDeck.remainder
    end
  end

  modifierDeck.shuffle()
end


function Character.adjustAttackModifierDeck(modifierDeck, additionalModifierDeck, info)
  for _, card in TableUtil.pairs(info.add) do
    if additionalModifierDeck.tag == Tag.CARD then
      additionalModifierDeck.putObject(modifierDeck)
      break
    end
    local foundCard = Character.findModifierCard(additionalModifierDeck, card)
    additionalModifierDeck.takeObject({
      guid = foundCard.guid,
      position = positions.getSafe(),
      smooth = false,
      callback_function = function(card) card.putObject(modifierDeck) end
    })
  end

  for _, card in TableUtil.pairs(info.remove) do
    local foundCard = Character.findModifierCard(modifierDeck, card)
    modifierDeck.takeObject({
      guid = foundCard.guid,
      position = positions.getSafe(),
      smooth = false,
      callback_function = function(card) card.destruct() end})
  end

  if info.ignore then
  end
end


function Character.findModifierCard(deck, name)
  local searchPattern = "^" .. names.ATTACK_MODIFIER .. " " .. StringUtil.escapePattern(name) .. "$"
  return Utils.findObjectInfoInStack(deck, {name=searchPattern})
end


function Character.loadItems(playerZone, character)
  local characterSheet = Component.characterSheet(playerZone)
  local playerMat = Component.playerMat(playerZone)

  local ignoreNegItemEffects = Character.hasNegItemEffectsPerk(character)

  local itemsText = ""
  for _, item in TableUtil.pairs(character.items) do
    local itemPosition
    if item.position and snaps[item.position] then
      itemPosition = Utils.getSnapPosition(playerMat, snaps[item.position])
    else
      itemPosition = positions.relativeToZone(playerZone, positions.ITEM_UNEQUIPPED)
    end

    Shop.takeItem(item.name, itemPosition, Rotation.NORTH)
    itemsText = itemsText .. "\n" .. item.name

    -- Perform check for adding of Negative Item Effects (-1 cards)
    if not ignoreNegItemEffects then
      local negativeEffect = Game.ITEMS.NegativeEffects[item.name]
      if negativeEffect then
        for i = 1, negativeEffect do
          Character.dealNegativeItemEffectCard(itemPosition)
        end
      end
    end

  end
  characterSheet.UI.setAttribute("Items", "text", itemsText)
end

function Character.hasNegItemEffectsPerk(character)
  local perkInfo = Game.CLASSES[character.class].perks
  for _, perk in pairs(character.perks) do
    if(perkInfo[perk].ignore == "I") then
      return true
    end
  end
  return false
end

function Character.dealNegativeItemEffectCard(itemPosition)
  local deck = getObjectFromGUID(guids.PLAYER_MINUS_ONE_DECK)
  deck.takeObject({
    smooth = false,
    -- position set to ensure PLayer -1 cards placed on top.
    position={itemPosition.x, itemPosition.y+1, itemPosition.z}
  })
end

function Character.moveToHand(object, playerZone, hand)
  local playerName = Game.PLAYERS[playerZone]
  object.deal(1, playerName, hand)
end


function Character.getLevel(curXP)
  if not curXP then curXP = 0 end
  for i, xp in pairs(Game.XP_REQUIREMENTS) do
    if curXP < xp then
      return i-1
    end
  end
  return 9
end


function Character.save(playerZone)
  local characterMat = Component.characterMat(playerZone)
  if not characterMat then
    return {}
  end

  local playerMat = Component.playerMat(playerZone)
  local characterSheet = Component.characterSheet(playerZone)
  local characterSheetButtons = characterSheet.getTable("buttons")

  character = {}
  character.class = characterMat.getDescription()
  character.name = characterSheet.UI.getAttribute("Name", "text")
  character.xp = tonumber(characterSheet.UI.getAttribute("xp", "text"))
  character.gold = tonumber(characterSheet.UI.getAttribute("gold", "text"))
  character.notes = StringUtil.split(characterSheet.UI.getAttribute("NotesFront", "text"), {"\n"})
  character.hiddenNotes = StringUtil.split(characterSheet.UI.getAttribute("Notes", "text"), {"\n"})

  local totalCheckmarks = 0
  for i=1, 18 do
    if characterSheetButtons["notes"..i].label ~= "" then
      totalCheckmarks = totalCheckmarks + 1
    end
  end
  character.checkmarks = totalCheckmarks

  character.perks = {}
  for i=1, 15 do
    if characterSheetButtons["perk"..i].label ~= "" then
      table.insert(character.perks, i)
    end
  end

  character.items = Character.saveItems(playerZone)
  character.abilities = Character.saveAbilities(playerZone)
  character.quest = Character.saveQuest(playerZone)

  return character
end


function Character.saveItems(playerZone)
  local playerMat = Utils.findObjectInZone(playerZone, {name=names.PLAYER_MAT})
  local items = {}
  local zoneObjects = getObjectFromGUID(playerZone).getObjects()
  Character.saveItemFromObjects(zoneObjects, playerMat, items)

  return items
end


function Character.saveItemFromObjects(objects, playerMat, items)
  for _, object in pairs(objects) do
    if Component.IsItemCard(object) then
      local item = {name=object.getName(), position=Character.getItemPosition(playerMat, object)}
      table.insert(items, item)
    elseif Component.isDeck(object) then
      local deckObjects = DeckUtil.getContainedObjects(object)
      Character.saveItemFromObjects(deckObjects, playerMat, items)
    end
  end
end


function Character.getItemPosition(playerMat, object)
  -- TODO The snap module is used for all snap points not only player mat snaps. So this currently
  -- only works, because the player mat snaps are defined first. This should be changed, so that it
  -- works regardless of definition order
  for name, snap in pairs(snaps) do
    if Utils.getSnapPosition(playerMat, snap) == object.getPosition() then
      return name
    end
  end

  return "Unequipped"
end


function Character.saveAbilities(playerZone)
  local class = Character.findClassInZone(playerZone)
  local abilities = {}
  local zoneObjects = getObjectFromGUID(playerZone).getObjects()
  Character.saveAbilitiesFromObjects(zoneObjects, class, abilities)

  return abilities
end

function Character.saveAbilitiesFromObjects(objects, class, abilities)
  for _, object in pairs(objects) do
    if Component.isAbilityCardForClass(object, class) then
      local name = Component.getAbilityName(object)
      if not Component.isStartingAbility(name, class) then
        table.insert(abilities, name)
      end
    elseif Component.isDeck(object) and not Component.isAbilityDeck(object) then
      local deckObjects = DeckUtil.getContainedObjects(object)
      Character.saveAbilitiesFromObjects(deckObjects, class, abilities)
    end
  end
end


function Character.saveQuest(playerZone)
  for _, object in pairs(getObjectFromGUID(playerZone).getObjects()) do
    if Component.isPersonalQuestCard(object) then
      return Component.getQuestName(object)
    end
  end
  return nil
end


function Character.findZoneForClass(className)
  for _, playerZone in pairs(guids.ZONES) do
    local characterMat = Component.characterMat(playerZone)
    if characterMat and characterMat.getDescription() == className then
      return playerZone
    end
  end
  return nil
end


function Character.findClassInZone(playerZone)
  local characterMat = Component.characterMat(playerZone)
  if characterMat then
    return characterMat.getDescription()
  end
  return nil
end
