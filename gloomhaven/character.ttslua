Character = {}


function Character.load(index, character)
  local playerZone = guids.ZONES[index]
  getObjectFromGUID(guids.ADD_PLAYERS[index]).call("addPlayer")

  Utils.waitForObjectInZone(playerZone, {name=names.PLAYER_MAT},
                            function() Character.unpackCharacterBox(playerZone, character) end)
end


function Character.unpackCharacterBox(playerZone, character)
  local playerMat = Component.playerMat(playerZone)
  local characterBox = getObjectFromGUID(Game.CLASSES[character.class].box_guid)

  characterBox.takeObject({
    position = playerMat.getPosition()
  })

  Utils.waitForObjectInZone(playerZone, {name=names.CHARACTER_SHEET},
                            function() Character.doLoad(playerZone, character) end)
end


function Character.doLoad(playerZone, character)
  -- still need more waiting to init the UI of the sheet :-(
  Wait.time(function() Character.loadCharacterSheet(playerZone, character) end, 1)
  Wait.time(function() Character.loadMaxHp(playerZone, character) end, 5)
  Character.loadAbilities(playerZone, character)
  Character.loadQuest(playerZone, character)
end


function Character.loadCharacterSheet(playerZone, character)
  local characterSheet = Component.characterSheet(playerZone)

  if character.name then
    characterSheet.UI.setAttribute("Name", "text", character.name)
  end
  if character.gold then
    characterSheet.call('addEx', {name='gold', amount=character.gold})
  end
  if character.xp then
    characterSheet.call('addEx', {name='xp', amount=character.xp})
  end
  if character.checkmarks then
    for i=1, character.checkmarks do
      characterSheet.call('clickedToggle', "notes"..tostring(i))
    end
  end
  if character.perks then
    Character.loadPerks(playerZone, character)
  end
  if character.items then
    Character.loadItems(playerZone, character)
  end
  if character.notes then
    characterSheet.UI.setAttribute("NotesFront", "text", table.concat(character.notes, "\n"))
  end
  if character.hidden_notes then
    characterSheet.UI.setAttribute("Notes", "text", table.concat(character.hidden_notes, "\n"))
  end
end


function Character.loadMaxHp(playerZone, character)
  local characterInfo = Game.CLASSES[character.class]
  local level = Character.getLevel(character.xp)
  local maxHealth = characterInfo.hp[level]

  Character.loadFigureHealth(playerZone, character.class, maxHealth)
  local tokenName = characterInfo.hp[1] .. " hp"
  local healthToken = Utils.findObjectInZone(playerZone, {name=tokenName})
  healthToken.setState(maxHealth)

  if characterInfo.extra_figure then
    maxHealth = characterInfo.extra_figure.hp[level]
    Character.loadFigureHealth(playerZone, characterInfo.extra_figure.name, maxHealth)
  end
end


function Character.loadFigureHealth(playerZone, name, health)
  local figure = Utils.findObjectInZone(playerZone, {name=name, tag=Tag.FIGURINE})

  figure.getVar('health')["max"] = health
  figure.getVar('health')["value"] = health
  figure.call('setHealth')
end

function Character.loadAbilities(playerZone, character)
  if not character.abilities then return end

  local abilityDeck = Component.abilityDeck(playerZone)
  local secondHandPos = {abilityDeck.getPosition().x,3,-59}
  for _, ability in pairs(character.abilities) do
    local abilityCard = Utils.findObjectInfoInStack(abilityDeck, {name=ability})
    abilityDeck.takeObject({
      position = secondHandPos,
      guid = abilityCard.guid
    })
  end
end


function Character.loadQuest(playerZone, character)
  if not character.quest then return end

  local callback = function(card) card.setPosition(positions.relativeToZone(playerZone, positions.QUEST_CARD)) end
  Quest.take(character.quest, callback)
end


function Character.loadPerks(playerZone, character)
  local perkInfo = Game.CLASSES[character.class].perks
  local characterSheet = Component.characterSheet(playerZone)
  local modifierDeck = Utils.findObjectInZone(playerZone, {name=names.MODIFIER_DECK, description="Player"})
  local isOtherDeck = function(obj) return obj.getName():find(names.MODIFIER_DECK)
                                           and obj.getGUID() ~= modifierDeck.getGUID()
                                    end
  local additionalModifierDeck = Utils.findObjectInZone(playerZone, {func=isOtherDeck})

  for _, perk in pairs(character.perks) do
    characterSheet.call('clickedToggle', "perk"..tostring(perk))
    Character.adjustAttackModifierDeck(modifierDeck, additionalModifierDeck, perkInfo[perk])
    if additionalModifierDeck.remainder then
      -- Remainder may only live for a single frame after last card is taken
      -- May need to move this into the adjustAttackModifierDeck routine itself to reduce
      -- any delay.
      additionalModifierDeck = additionalModifierDeck.remainder
    end
  end

  modifierDeck.shuffle()
end


function Character.adjustAttackModifierDeck(modifierDeck, additionalModifierDeck, info)
  if info.add then
    for _, card in pairs(info.add) do
      if additionalModifierDeck.tag == Tag.CARD then
        additionalModifierDeck.putObject(modifierDeck)
        break
      end
      local foundCard = Character.findModifierCard(additionalModifierDeck, card)
      additionalModifierDeck.takeObject({
        guid = foundCard.guid,
        position = positions.getSafe(),
        smooth = false,
        callback_function = function(card) card.putObject(modifierDeck) end
      })
    end
  end

  if info.remove then
    for _, card in pairs(info.remove) do
      local foundCard = Character.findModifierCard(modifierDeck, card)
      modifierDeck.takeObject({
        guid = foundCard.guid,
        position = positions.getSafe(),
        smooth = false,
        callback_function = function(card) card.destruct() end})
    end
  end

  if info.ignore then
  end
end


function Character.findModifierCard(deck, name)
  local searchPattern = "^" .. names.ATTACK_MODIFIER .. " " .. StringUtil.escapePattern(name) .. "$"
  return Utils.findObjectInfoInStack(deck, {name=searchPattern})
end


function Character.loadItems(playerZone, character)
  local characterSheet = Component.characterSheet(playerZone)
  local playerMat = Component.playerMat(playerZone)

  local itemsText = ""
  for _, item in pairs(character.items) do
    local itemPosition
    if item.position and snaps[item.position] then
      itemPosition = Utils.getSnapPosition(playerMat, snaps[item.position])
    else
      itemPosition = positions.relativeToZone(playerZone, positions.ITEM_UNEQUIPPED)
    end
    Shop.getItem(item.name, itemPosition)
    itemsText = itemsText .. "\n" .. item.name
  end
  characterSheet.UI.setAttribute("Items", "text", itemsText)
end


function Character.moveToHand(object, playerZone, hand)
  local playerName = Game.PLAYERS[playerZone]
  object.deal(1, playerName, hand)
end


function Character.getLevel(curXP)
  for i, xp in pairs(Game.XP_REQUIREMENTS) do
    if curXP < xp then
      return i-1
    end
  end
  return 9
end


function Character.save(playerZone)
  local characterMat = Component.characterMat(playerZone)
  if not characterMat then
    return {}
  end

  local playerMat = Component.playerMat(playerZone)
  local characterSheet = Component.characterSheet(playerZone)
  local characterSheetButtons = characterSheet.getTable("buttons")

  character = {}
  character.class = characterMat.getDescription()
  character.name = characterSheet.UI.getAttribute("Name", "text")
  character.xp = tonumber(characterSheet.UI.getAttribute("xp", "text"))
  character.gold = tonumber(characterSheet.UI.getAttribute("gold", "text"))
  character.notes = StringUtil.split(characterSheet.UI.getAttribute("NotesFront", "text"), {"\n"})
  character.hidden_notes = StringUtil.split(characterSheet.UI.getAttribute("Notes", "text"), {"\n"})

  local totalCheckmarks = 0
  for i=1, 18 do
    if characterSheetButtons["notes"..i].label ~= "" then
      totalCheckmarks = totalCheckmarks + 1
    end
  end
  character.checkmarks = totalCheckmarks

  character.perks = {}
  for i=1, 15 do
    if characterSheetButtons["perk"..i].label ~= "" then
      table.insert(character.perks, i)
    end
  end

  character.items = Character.saveItems(playerZone)
  character.abilities = Character.saveAbilities(playerZone)
  character.quest = Character.saveQuest(playerZone)

  return character
end


function Character.saveItems(playerZone)
  local playerMat = Utils.findObjectInZone(playerZone, {name=names.PLAYER_MAT})
  local items = {}
  for _, object in pairs(getObjectFromGUID(playerZone).getObjects()) do
    if Component.IsItemCard(object) then
      local item = {name=object.getName(), position=Character.getItemPosition(playerMat, object)}
      table.insert(items, item)
    elseif object.tag == Tag.DECK then
      for _, card in pairs(object.getObjects()) do
        if Component.IsItemCardInfo(card) then
          local item = {name=card.name, position=Character.getItemPosition(playerMat, object)}
          table.insert(items, item)
        end
      end
    end
  end

  return items
end


function Character.getItemPosition(playerMat, object)
  -- TODO The snap module is used for all snap points not only player mat snaps. So this currently
  -- only works, because the player mat snaps are defined first. This should be changed, so that it
  -- works regardless of definition order
  for name, snap in pairs(snaps) do
    if Utils.getSnapPosition(playerMat, snap) == object.getPosition() then
      return name
    end
  end

  return "Unequipped"
end


function Character.saveAbilities(playerZone)
  local class = Character.findClassInZone(playerZone)
  local abilities = {}

  for _, object in pairs(getObjectFromGUID(playerZone).getObjects()) do
    if Component.isAbilityCardForClass(object, class) then
      local name = Component.getAbilityName(object)
      if not Component.isStartingAbility(name, class) then
        table.insert(abilities, name)
      end
    end
  end

  return abilities
end


function Character.saveQuest(playerZone)
  for _, object in pairs(getObjectFromGUID(playerZone).getObjects()) do
    if Component.isPersonalQuestCard(object) then
      local cardId = object.getData().CardID
      local cardIndex = tonumber(tostring(cardId):sub(-2, -1))
      for name, quest in pairs(Game.QUESTS) do
        if quest.index == cardIndex then return name end
      end
    end
  end
  return nil
end


function Character.findZoneForClass(className)
  for _, playerZone in pairs(guids.ZONES) do
    local characterMat = Component.characterMat(playerZone)
    if characterMat and characterMat.getDescription() == className then
      return playerZone
    end
  end
  return nil
end


function Character.findClassInZone(playerZone)
  local characterMat = Component.characterMat(playerZone)
  if characterMat then
    return characterMat.getDescription()
  end
  return nil
end
