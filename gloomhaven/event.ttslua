Event = {}

function Event.loadAll(events)
  if not events then return end
  
  Event.load(events.city, guids.CITY_EVENTS_DECK_INITIAL, guids.CITY_EVENTS_DECK, snaps.CITY_EVENTS_DECK)
  Event.load(events.road, guids.ROAD_EVENTS_DECK_INITIAL, guids.ROAD_EVENTS_DECK, snaps.ROAD_EVENTS_DECK)
end


function Event.load(events, initialDeckGuid, deckGuid, snapPoint)
  deck = getObjectFromGUID(deckGuid)
  deck.putObject(getObjectFromGUID(initialDeckGuid))

  local bottomCards = Event.findBottomDeck(events, deck)
  local addedCards = Event.findAddedCards(events, deck, bottomCards)

  TableUtil.shuffle(addedCards)
  local eventCards = TableUtil.append(bottomCards, addedCards)

  Event.dealEvents(eventCards, snapPoint)
end


function Event.findBottomDeck(events, deck)
  if not events.bottomUp then return {} end

  local eventsToAdd = {}
  for i, event in pairs(events.bottomUp) do
    local eventName = string.format("%02d", event)
    local eventCard = Utils.findObjectInfoInStack(deck, {name=eventName})
    table.insert(eventsToAdd, eventCard.guid)
  end

  return eventsToAdd
end


function Event.findAddedCards(events, deck, alreadyAdded)
  local eventsToAdd = {}
  for _, eventCard in pairs(deck.getObjects()) do
    local eventNumber = tonumber(eventCard.name)
    if not TableUtil.contains(alreadyAdded, eventCard.guid)
       and Event.isAdded(events, eventNumber)
       and not Event.isRemoved(events, eventNumber)
    then
      table.insert(eventsToAdd, eventCard.guid)
    end
  end

  return eventsToAdd
end


function Event.isRemoved(events, eventNumber)
  return events.remove and TableUtil.contains(events.remove, eventNumber)
end


function Event.isAdded(events, eventNumber)
  return eventNumber <= 30
         or (events.add and TableUtil.contains(events.add, eventNumber))
end


function Event.dealEvents(eventCards, snapPoint)
  local eventPosition = Event.getPosition(snapPoint)
  for i, event in pairs(eventCards) do
    local offset = i * 0.2
    deck.takeObject({
      guid = event,
      position = eventPosition + vector(0, offset, 0),
      rotation = Rotation.NORTH,
      smooth = false
    })
  end
end


function Event.save()
  events = {}
  events.city = Event.saveEventsFromDeck(snaps.CITY_EVENTS_DECK)
  events.road = Event.saveEventsFromDeck(snaps.ROAD_EVENTS_DECK)

  return events
end


function Event.saveEventsFromDeck(snapPoint)
  local hitObjects = Physics.cast({
    origin = Event.getPosition(snapPoint) + vector(0, -0.05, 0),
    direction = Direction.UP,
    max_distance = 0.1
  })

  local eventsFromDeck = {}
  eventsFromDeck.bottomUp = {}
  for _, object in pairs(hitObjects) do
    object = object.hit_object
    if object.tag == "Deck" then
      local eventNumbers = {}
      for _, card in pairs(object.getObjects()) do
        table.insert(eventsFromDeck.bottomUp, tonumber(card.name))
      end
    end
  end

  return eventsFromDeck
end


function Event.getPosition(snapPoint)
  return Utils.getSnapPosition(getObjectFromGUID(guids.EVENTS_MAT), snapPoint)
end
